
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://jaxleyverse.github.io/jaxley/dev/reference/modules/">
      
      
        <link rel="prev" href="../../code_of_conduct/">
      
      
        <link rel="next" href="../integration/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>Modules - Jaxley</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.35f28582.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="Jaxley" class="md-header__button md-logo" aria-label="Jaxley" data-md-component="logo">
      
  <img src="../../logo_white.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Jaxley
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Modules
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="http://github.com/jaxleyverse/jaxley" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    jaxleyverse/jaxley
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Jaxley" class="md-nav__button md-logo" aria-label="Jaxley" data-md-component="logo">
      
  <img src="../../logo_white.png" alt="logo">

    </a>
    Jaxley
  </label>
  
    <div class="md-nav__source">
      <a href="http://github.com/jaxleyverse/jaxley" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"/></svg>
  </div>
  <div class="md-source__repository">
    jaxleyverse/jaxley
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Tutorials
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Tutorials
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/01_morph_neurons.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Getting started
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/02_small_network.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Run a network simulation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/03_setting_parameters.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Set parameters
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/04_jit_and_vmap.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Accelerate simulations
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/05_channel_and_synapse_models.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Define your own channels
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/06_groups.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Define groups
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/08_importing_morphologies.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Read and handle SWC files
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../tutorial/07_gradient_descent.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Training models
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../install/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installation
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Contributing
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Contributing
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../contribute/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Guide
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../code_of_conduct/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Code of Conduct
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    API Reference
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            API Reference
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Modules
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Modules
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#module" class="md-nav__link">
    <span class="md-ellipsis">
      Module
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Module">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module" class="md-nav__link">
    <span class="md-ellipsis">
      Module
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.initialized" class="md-nav__link">
    <span class="md-ellipsis">
      initialized
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.shape" class="md-nav__link">
    <span class="md-ellipsis">
      shape
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.add_to_group" class="md-nav__link">
    <span class="md-ellipsis">
      add_to_group
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.clamp" class="md-nav__link">
    <span class="md-ellipsis">
      clamp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.compute_xyz" class="md-nav__link">
    <span class="md-ellipsis">
      compute_xyz
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_set" class="md-nav__link">
    <span class="md-ellipsis">
      data_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_stimulate" class="md-nav__link">
    <span class="md-ellipsis">
      data_stimulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_recordings" class="md-nav__link">
    <span class="md-ellipsis">
      delete_recordings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_stimuli" class="md-nav__link">
    <span class="md-ellipsis">
      delete_stimuli
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_trainables" class="md-nav__link">
    <span class="md-ellipsis">
      delete_trainables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_all_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_all_states" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_states
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      get_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_states_from_nodes_and_edges" class="md-nav__link">
    <span class="md-ellipsis">
      get_states_from_nodes_and_edges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.init_conds" class="md-nav__link">
    <span class="md-ellipsis">
      init_conds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.init_states" class="md-nav__link">
    <span class="md-ellipsis">
      init_states
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.initialize" class="md-nav__link">
    <span class="md-ellipsis">
      initialize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.make_trainable" class="md-nav__link">
    <span class="md-ellipsis">
      make_trainable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.move" class="md-nav__link">
    <span class="md-ellipsis">
      move
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.move_to" class="md-nav__link">
    <span class="md-ellipsis">
      move_to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.record" class="md-nav__link">
    <span class="md-ellipsis">
      record
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.rotate" class="md-nav__link">
    <span class="md-ellipsis">
      rotate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.set" class="md-nav__link">
    <span class="md-ellipsis">
      set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.show" class="md-nav__link">
    <span class="md-ellipsis">
      show
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.step" class="md-nav__link">
    <span class="md-ellipsis">
      step
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.stimulate" class="md-nav__link">
    <span class="md-ellipsis">
      stimulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.to_jax" class="md-nav__link">
    <span class="md-ellipsis">
      to_jax
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.vis" class="md-nav__link">
    <span class="md-ellipsis">
      vis
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compartment" class="md-nav__link">
    <span class="md-ellipsis">
      Compartment
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Compartment">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.compartment.Compartment" class="md-nav__link">
    <span class="md-ellipsis">
      Compartment
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#branch" class="md-nav__link">
    <span class="md-ellipsis">
      Branch
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Branch">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch" class="md-nav__link">
    <span class="md-ellipsis">
      Branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch.init_branch_conds" class="md-nav__link">
    <span class="md-ellipsis">
      init_branch_conds
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cell" class="md-nav__link">
    <span class="md-ellipsis">
      Cell
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cell">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell" class="md-nav__link">
    <span class="md-ellipsis">
      Cell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.init_conds" class="md-nav__link">
    <span class="md-ellipsis">
      init_conds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.init_morph" class="md-nav__link">
    <span class="md-ellipsis">
      init_morph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.update_summed_coupling_conds" class="md-nav__link">
    <span class="md-ellipsis">
      update_summed_coupling_conds
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.init_conds" class="md-nav__link">
    <span class="md-ellipsis">
      init_conds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.init_syns" class="md-nav__link">
    <span class="md-ellipsis">
      init_syns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.vis" class="md-nav__link">
    <span class="md-ellipsis">
      vis
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../integration/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Simulation
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../mechanisms/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Mechansims
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../connect/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Connecting Cells
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../optimize/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Optimization
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Utils
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../faq/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    FAQ
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../credits/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Credits
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#module" class="md-nav__link">
    <span class="md-ellipsis">
      Module
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Module">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module" class="md-nav__link">
    <span class="md-ellipsis">
      Module
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.initialized" class="md-nav__link">
    <span class="md-ellipsis">
      initialized
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.shape" class="md-nav__link">
    <span class="md-ellipsis">
      shape
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.add_to_group" class="md-nav__link">
    <span class="md-ellipsis">
      add_to_group
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.clamp" class="md-nav__link">
    <span class="md-ellipsis">
      clamp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.compute_xyz" class="md-nav__link">
    <span class="md-ellipsis">
      compute_xyz
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_set" class="md-nav__link">
    <span class="md-ellipsis">
      data_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.data_stimulate" class="md-nav__link">
    <span class="md-ellipsis">
      data_stimulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_recordings" class="md-nav__link">
    <span class="md-ellipsis">
      delete_recordings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_stimuli" class="md-nav__link">
    <span class="md-ellipsis">
      delete_stimuli
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.delete_trainables" class="md-nav__link">
    <span class="md-ellipsis">
      delete_trainables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_all_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_all_states" class="md-nav__link">
    <span class="md-ellipsis">
      get_all_states
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_parameters" class="md-nav__link">
    <span class="md-ellipsis">
      get_parameters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.get_states_from_nodes_and_edges" class="md-nav__link">
    <span class="md-ellipsis">
      get_states_from_nodes_and_edges
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.init_conds" class="md-nav__link">
    <span class="md-ellipsis">
      init_conds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.init_states" class="md-nav__link">
    <span class="md-ellipsis">
      init_states
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.initialize" class="md-nav__link">
    <span class="md-ellipsis">
      initialize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.make_trainable" class="md-nav__link">
    <span class="md-ellipsis">
      make_trainable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.move" class="md-nav__link">
    <span class="md-ellipsis">
      move
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.move_to" class="md-nav__link">
    <span class="md-ellipsis">
      move_to
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.record" class="md-nav__link">
    <span class="md-ellipsis">
      record
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.rotate" class="md-nav__link">
    <span class="md-ellipsis">
      rotate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.set" class="md-nav__link">
    <span class="md-ellipsis">
      set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.show" class="md-nav__link">
    <span class="md-ellipsis">
      show
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.step" class="md-nav__link">
    <span class="md-ellipsis">
      step
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.stimulate" class="md-nav__link">
    <span class="md-ellipsis">
      stimulate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.to_jax" class="md-nav__link">
    <span class="md-ellipsis">
      to_jax
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.base.Module.vis" class="md-nav__link">
    <span class="md-ellipsis">
      vis
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#compartment" class="md-nav__link">
    <span class="md-ellipsis">
      Compartment
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Compartment">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.compartment.Compartment" class="md-nav__link">
    <span class="md-ellipsis">
      Compartment
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#branch" class="md-nav__link">
    <span class="md-ellipsis">
      Branch
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Branch">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch" class="md-nav__link">
    <span class="md-ellipsis">
      Branch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.branch.Branch.init_branch_conds" class="md-nav__link">
    <span class="md-ellipsis">
      init_branch_conds
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#cell" class="md-nav__link">
    <span class="md-ellipsis">
      Cell
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cell">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell" class="md-nav__link">
    <span class="md-ellipsis">
      Cell
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.init_conds" class="md-nav__link">
    <span class="md-ellipsis">
      init_conds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.init_morph" class="md-nav__link">
    <span class="md-ellipsis">
      init_morph
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.cell.Cell.update_summed_coupling_conds" class="md-nav__link">
    <span class="md-ellipsis">
      update_summed_coupling_conds
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Network">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network" class="md-nav__link">
    <span class="md-ellipsis">
      Network
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.init_conds" class="md-nav__link">
    <span class="md-ellipsis">
      init_conds
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.init_syns" class="md-nav__link">
    <span class="md-ellipsis">
      init_syns
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#jaxley.modules.network.Network.vis" class="md-nav__link">
    <span class="md-ellipsis">
      vis
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>Modules</h1>

<h2 id="module">Module<a class="headerlink" href="#module" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.base.Module"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="abc.ABC">ABC</span></code></p>


        <p>Module base class.</p>
<p>Modules are everything that can be passed to <code>jx.integrate</code>, i.e. compartments,
branches, cells, and networks.</p>
<p>This base class defines the scaffold for all jaxley modules (compartments,
branches, cells, networks).</p>

              <details class="quote">
                <summary>Source code in <code>jaxley/modules/base.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  34</span>
<span class="normal">  35</span>
<span class="normal">  36</span>
<span class="normal">  37</span>
<span class="normal">  38</span>
<span class="normal">  39</span>
<span class="normal">  40</span>
<span class="normal">  41</span>
<span class="normal">  42</span>
<span class="normal">  43</span>
<span class="normal">  44</span>
<span class="normal">  45</span>
<span class="normal">  46</span>
<span class="normal">  47</span>
<span class="normal">  48</span>
<span class="normal">  49</span>
<span class="normal">  50</span>
<span class="normal">  51</span>
<span class="normal">  52</span>
<span class="normal">  53</span>
<span class="normal">  54</span>
<span class="normal">  55</span>
<span class="normal">  56</span>
<span class="normal">  57</span>
<span class="normal">  58</span>
<span class="normal">  59</span>
<span class="normal">  60</span>
<span class="normal">  61</span>
<span class="normal">  62</span>
<span class="normal">  63</span>
<span class="normal">  64</span>
<span class="normal">  65</span>
<span class="normal">  66</span>
<span class="normal">  67</span>
<span class="normal">  68</span>
<span class="normal">  69</span>
<span class="normal">  70</span>
<span class="normal">  71</span>
<span class="normal">  72</span>
<span class="normal">  73</span>
<span class="normal">  74</span>
<span class="normal">  75</span>
<span class="normal">  76</span>
<span class="normal">  77</span>
<span class="normal">  78</span>
<span class="normal">  79</span>
<span class="normal">  80</span>
<span class="normal">  81</span>
<span class="normal">  82</span>
<span class="normal">  83</span>
<span class="normal">  84</span>
<span class="normal">  85</span>
<span class="normal">  86</span>
<span class="normal">  87</span>
<span class="normal">  88</span>
<span class="normal">  89</span>
<span class="normal">  90</span>
<span class="normal">  91</span>
<span class="normal">  92</span>
<span class="normal">  93</span>
<span class="normal">  94</span>
<span class="normal">  95</span>
<span class="normal">  96</span>
<span class="normal">  97</span>
<span class="normal">  98</span>
<span class="normal">  99</span>
<span class="normal"> 100</span>
<span class="normal"> 101</span>
<span class="normal"> 102</span>
<span class="normal"> 103</span>
<span class="normal"> 104</span>
<span class="normal"> 105</span>
<span class="normal"> 106</span>
<span class="normal"> 107</span>
<span class="normal"> 108</span>
<span class="normal"> 109</span>
<span class="normal"> 110</span>
<span class="normal"> 111</span>
<span class="normal"> 112</span>
<span class="normal"> 113</span>
<span class="normal"> 114</span>
<span class="normal"> 115</span>
<span class="normal"> 116</span>
<span class="normal"> 117</span>
<span class="normal"> 118</span>
<span class="normal"> 119</span>
<span class="normal"> 120</span>
<span class="normal"> 121</span>
<span class="normal"> 122</span>
<span class="normal"> 123</span>
<span class="normal"> 124</span>
<span class="normal"> 125</span>
<span class="normal"> 126</span>
<span class="normal"> 127</span>
<span class="normal"> 128</span>
<span class="normal"> 129</span>
<span class="normal"> 130</span>
<span class="normal"> 131</span>
<span class="normal"> 132</span>
<span class="normal"> 133</span>
<span class="normal"> 134</span>
<span class="normal"> 135</span>
<span class="normal"> 136</span>
<span class="normal"> 137</span>
<span class="normal"> 138</span>
<span class="normal"> 139</span>
<span class="normal"> 140</span>
<span class="normal"> 141</span>
<span class="normal"> 142</span>
<span class="normal"> 143</span>
<span class="normal"> 144</span>
<span class="normal"> 145</span>
<span class="normal"> 146</span>
<span class="normal"> 147</span>
<span class="normal"> 148</span>
<span class="normal"> 149</span>
<span class="normal"> 150</span>
<span class="normal"> 151</span>
<span class="normal"> 152</span>
<span class="normal"> 153</span>
<span class="normal"> 154</span>
<span class="normal"> 155</span>
<span class="normal"> 156</span>
<span class="normal"> 157</span>
<span class="normal"> 158</span>
<span class="normal"> 159</span>
<span class="normal"> 160</span>
<span class="normal"> 161</span>
<span class="normal"> 162</span>
<span class="normal"> 163</span>
<span class="normal"> 164</span>
<span class="normal"> 165</span>
<span class="normal"> 166</span>
<span class="normal"> 167</span>
<span class="normal"> 168</span>
<span class="normal"> 169</span>
<span class="normal"> 170</span>
<span class="normal"> 171</span>
<span class="normal"> 172</span>
<span class="normal"> 173</span>
<span class="normal"> 174</span>
<span class="normal"> 175</span>
<span class="normal"> 176</span>
<span class="normal"> 177</span>
<span class="normal"> 178</span>
<span class="normal"> 179</span>
<span class="normal"> 180</span>
<span class="normal"> 181</span>
<span class="normal"> 182</span>
<span class="normal"> 183</span>
<span class="normal"> 184</span>
<span class="normal"> 185</span>
<span class="normal"> 186</span>
<span class="normal"> 187</span>
<span class="normal"> 188</span>
<span class="normal"> 189</span>
<span class="normal"> 190</span>
<span class="normal"> 191</span>
<span class="normal"> 192</span>
<span class="normal"> 193</span>
<span class="normal"> 194</span>
<span class="normal"> 195</span>
<span class="normal"> 196</span>
<span class="normal"> 197</span>
<span class="normal"> 198</span>
<span class="normal"> 199</span>
<span class="normal"> 200</span>
<span class="normal"> 201</span>
<span class="normal"> 202</span>
<span class="normal"> 203</span>
<span class="normal"> 204</span>
<span class="normal"> 205</span>
<span class="normal"> 206</span>
<span class="normal"> 207</span>
<span class="normal"> 208</span>
<span class="normal"> 209</span>
<span class="normal"> 210</span>
<span class="normal"> 211</span>
<span class="normal"> 212</span>
<span class="normal"> 213</span>
<span class="normal"> 214</span>
<span class="normal"> 215</span>
<span class="normal"> 216</span>
<span class="normal"> 217</span>
<span class="normal"> 218</span>
<span class="normal"> 219</span>
<span class="normal"> 220</span>
<span class="normal"> 221</span>
<span class="normal"> 222</span>
<span class="normal"> 223</span>
<span class="normal"> 224</span>
<span class="normal"> 225</span>
<span class="normal"> 226</span>
<span class="normal"> 227</span>
<span class="normal"> 228</span>
<span class="normal"> 229</span>
<span class="normal"> 230</span>
<span class="normal"> 231</span>
<span class="normal"> 232</span>
<span class="normal"> 233</span>
<span class="normal"> 234</span>
<span class="normal"> 235</span>
<span class="normal"> 236</span>
<span class="normal"> 237</span>
<span class="normal"> 238</span>
<span class="normal"> 239</span>
<span class="normal"> 240</span>
<span class="normal"> 241</span>
<span class="normal"> 242</span>
<span class="normal"> 243</span>
<span class="normal"> 244</span>
<span class="normal"> 245</span>
<span class="normal"> 246</span>
<span class="normal"> 247</span>
<span class="normal"> 248</span>
<span class="normal"> 249</span>
<span class="normal"> 250</span>
<span class="normal"> 251</span>
<span class="normal"> 252</span>
<span class="normal"> 253</span>
<span class="normal"> 254</span>
<span class="normal"> 255</span>
<span class="normal"> 256</span>
<span class="normal"> 257</span>
<span class="normal"> 258</span>
<span class="normal"> 259</span>
<span class="normal"> 260</span>
<span class="normal"> 261</span>
<span class="normal"> 262</span>
<span class="normal"> 263</span>
<span class="normal"> 264</span>
<span class="normal"> 265</span>
<span class="normal"> 266</span>
<span class="normal"> 267</span>
<span class="normal"> 268</span>
<span class="normal"> 269</span>
<span class="normal"> 270</span>
<span class="normal"> 271</span>
<span class="normal"> 272</span>
<span class="normal"> 273</span>
<span class="normal"> 274</span>
<span class="normal"> 275</span>
<span class="normal"> 276</span>
<span class="normal"> 277</span>
<span class="normal"> 278</span>
<span class="normal"> 279</span>
<span class="normal"> 280</span>
<span class="normal"> 281</span>
<span class="normal"> 282</span>
<span class="normal"> 283</span>
<span class="normal"> 284</span>
<span class="normal"> 285</span>
<span class="normal"> 286</span>
<span class="normal"> 287</span>
<span class="normal"> 288</span>
<span class="normal"> 289</span>
<span class="normal"> 290</span>
<span class="normal"> 291</span>
<span class="normal"> 292</span>
<span class="normal"> 293</span>
<span class="normal"> 294</span>
<span class="normal"> 295</span>
<span class="normal"> 296</span>
<span class="normal"> 297</span>
<span class="normal"> 298</span>
<span class="normal"> 299</span>
<span class="normal"> 300</span>
<span class="normal"> 301</span>
<span class="normal"> 302</span>
<span class="normal"> 303</span>
<span class="normal"> 304</span>
<span class="normal"> 305</span>
<span class="normal"> 306</span>
<span class="normal"> 307</span>
<span class="normal"> 308</span>
<span class="normal"> 309</span>
<span class="normal"> 310</span>
<span class="normal"> 311</span>
<span class="normal"> 312</span>
<span class="normal"> 313</span>
<span class="normal"> 314</span>
<span class="normal"> 315</span>
<span class="normal"> 316</span>
<span class="normal"> 317</span>
<span class="normal"> 318</span>
<span class="normal"> 319</span>
<span class="normal"> 320</span>
<span class="normal"> 321</span>
<span class="normal"> 322</span>
<span class="normal"> 323</span>
<span class="normal"> 324</span>
<span class="normal"> 325</span>
<span class="normal"> 326</span>
<span class="normal"> 327</span>
<span class="normal"> 328</span>
<span class="normal"> 329</span>
<span class="normal"> 330</span>
<span class="normal"> 331</span>
<span class="normal"> 332</span>
<span class="normal"> 333</span>
<span class="normal"> 334</span>
<span class="normal"> 335</span>
<span class="normal"> 336</span>
<span class="normal"> 337</span>
<span class="normal"> 338</span>
<span class="normal"> 339</span>
<span class="normal"> 340</span>
<span class="normal"> 341</span>
<span class="normal"> 342</span>
<span class="normal"> 343</span>
<span class="normal"> 344</span>
<span class="normal"> 345</span>
<span class="normal"> 346</span>
<span class="normal"> 347</span>
<span class="normal"> 348</span>
<span class="normal"> 349</span>
<span class="normal"> 350</span>
<span class="normal"> 351</span>
<span class="normal"> 352</span>
<span class="normal"> 353</span>
<span class="normal"> 354</span>
<span class="normal"> 355</span>
<span class="normal"> 356</span>
<span class="normal"> 357</span>
<span class="normal"> 358</span>
<span class="normal"> 359</span>
<span class="normal"> 360</span>
<span class="normal"> 361</span>
<span class="normal"> 362</span>
<span class="normal"> 363</span>
<span class="normal"> 364</span>
<span class="normal"> 365</span>
<span class="normal"> 366</span>
<span class="normal"> 367</span>
<span class="normal"> 368</span>
<span class="normal"> 369</span>
<span class="normal"> 370</span>
<span class="normal"> 371</span>
<span class="normal"> 372</span>
<span class="normal"> 373</span>
<span class="normal"> 374</span>
<span class="normal"> 375</span>
<span class="normal"> 376</span>
<span class="normal"> 377</span>
<span class="normal"> 378</span>
<span class="normal"> 379</span>
<span class="normal"> 380</span>
<span class="normal"> 381</span>
<span class="normal"> 382</span>
<span class="normal"> 383</span>
<span class="normal"> 384</span>
<span class="normal"> 385</span>
<span class="normal"> 386</span>
<span class="normal"> 387</span>
<span class="normal"> 388</span>
<span class="normal"> 389</span>
<span class="normal"> 390</span>
<span class="normal"> 391</span>
<span class="normal"> 392</span>
<span class="normal"> 393</span>
<span class="normal"> 394</span>
<span class="normal"> 395</span>
<span class="normal"> 396</span>
<span class="normal"> 397</span>
<span class="normal"> 398</span>
<span class="normal"> 399</span>
<span class="normal"> 400</span>
<span class="normal"> 401</span>
<span class="normal"> 402</span>
<span class="normal"> 403</span>
<span class="normal"> 404</span>
<span class="normal"> 405</span>
<span class="normal"> 406</span>
<span class="normal"> 407</span>
<span class="normal"> 408</span>
<span class="normal"> 409</span>
<span class="normal"> 410</span>
<span class="normal"> 411</span>
<span class="normal"> 412</span>
<span class="normal"> 413</span>
<span class="normal"> 414</span>
<span class="normal"> 415</span>
<span class="normal"> 416</span>
<span class="normal"> 417</span>
<span class="normal"> 418</span>
<span class="normal"> 419</span>
<span class="normal"> 420</span>
<span class="normal"> 421</span>
<span class="normal"> 422</span>
<span class="normal"> 423</span>
<span class="normal"> 424</span>
<span class="normal"> 425</span>
<span class="normal"> 426</span>
<span class="normal"> 427</span>
<span class="normal"> 428</span>
<span class="normal"> 429</span>
<span class="normal"> 430</span>
<span class="normal"> 431</span>
<span class="normal"> 432</span>
<span class="normal"> 433</span>
<span class="normal"> 434</span>
<span class="normal"> 435</span>
<span class="normal"> 436</span>
<span class="normal"> 437</span>
<span class="normal"> 438</span>
<span class="normal"> 439</span>
<span class="normal"> 440</span>
<span class="normal"> 441</span>
<span class="normal"> 442</span>
<span class="normal"> 443</span>
<span class="normal"> 444</span>
<span class="normal"> 445</span>
<span class="normal"> 446</span>
<span class="normal"> 447</span>
<span class="normal"> 448</span>
<span class="normal"> 449</span>
<span class="normal"> 450</span>
<span class="normal"> 451</span>
<span class="normal"> 452</span>
<span class="normal"> 453</span>
<span class="normal"> 454</span>
<span class="normal"> 455</span>
<span class="normal"> 456</span>
<span class="normal"> 457</span>
<span class="normal"> 458</span>
<span class="normal"> 459</span>
<span class="normal"> 460</span>
<span class="normal"> 461</span>
<span class="normal"> 462</span>
<span class="normal"> 463</span>
<span class="normal"> 464</span>
<span class="normal"> 465</span>
<span class="normal"> 466</span>
<span class="normal"> 467</span>
<span class="normal"> 468</span>
<span class="normal"> 469</span>
<span class="normal"> 470</span>
<span class="normal"> 471</span>
<span class="normal"> 472</span>
<span class="normal"> 473</span>
<span class="normal"> 474</span>
<span class="normal"> 475</span>
<span class="normal"> 476</span>
<span class="normal"> 477</span>
<span class="normal"> 478</span>
<span class="normal"> 479</span>
<span class="normal"> 480</span>
<span class="normal"> 481</span>
<span class="normal"> 482</span>
<span class="normal"> 483</span>
<span class="normal"> 484</span>
<span class="normal"> 485</span>
<span class="normal"> 486</span>
<span class="normal"> 487</span>
<span class="normal"> 488</span>
<span class="normal"> 489</span>
<span class="normal"> 490</span>
<span class="normal"> 491</span>
<span class="normal"> 492</span>
<span class="normal"> 493</span>
<span class="normal"> 494</span>
<span class="normal"> 495</span>
<span class="normal"> 496</span>
<span class="normal"> 497</span>
<span class="normal"> 498</span>
<span class="normal"> 499</span>
<span class="normal"> 500</span>
<span class="normal"> 501</span>
<span class="normal"> 502</span>
<span class="normal"> 503</span>
<span class="normal"> 504</span>
<span class="normal"> 505</span>
<span class="normal"> 506</span>
<span class="normal"> 507</span>
<span class="normal"> 508</span>
<span class="normal"> 509</span>
<span class="normal"> 510</span>
<span class="normal"> 511</span>
<span class="normal"> 512</span>
<span class="normal"> 513</span>
<span class="normal"> 514</span>
<span class="normal"> 515</span>
<span class="normal"> 516</span>
<span class="normal"> 517</span>
<span class="normal"> 518</span>
<span class="normal"> 519</span>
<span class="normal"> 520</span>
<span class="normal"> 521</span>
<span class="normal"> 522</span>
<span class="normal"> 523</span>
<span class="normal"> 524</span>
<span class="normal"> 525</span>
<span class="normal"> 526</span>
<span class="normal"> 527</span>
<span class="normal"> 528</span>
<span class="normal"> 529</span>
<span class="normal"> 530</span>
<span class="normal"> 531</span>
<span class="normal"> 532</span>
<span class="normal"> 533</span>
<span class="normal"> 534</span>
<span class="normal"> 535</span>
<span class="normal"> 536</span>
<span class="normal"> 537</span>
<span class="normal"> 538</span>
<span class="normal"> 539</span>
<span class="normal"> 540</span>
<span class="normal"> 541</span>
<span class="normal"> 542</span>
<span class="normal"> 543</span>
<span class="normal"> 544</span>
<span class="normal"> 545</span>
<span class="normal"> 546</span>
<span class="normal"> 547</span>
<span class="normal"> 548</span>
<span class="normal"> 549</span>
<span class="normal"> 550</span>
<span class="normal"> 551</span>
<span class="normal"> 552</span>
<span class="normal"> 553</span>
<span class="normal"> 554</span>
<span class="normal"> 555</span>
<span class="normal"> 556</span>
<span class="normal"> 557</span>
<span class="normal"> 558</span>
<span class="normal"> 559</span>
<span class="normal"> 560</span>
<span class="normal"> 561</span>
<span class="normal"> 562</span>
<span class="normal"> 563</span>
<span class="normal"> 564</span>
<span class="normal"> 565</span>
<span class="normal"> 566</span>
<span class="normal"> 567</span>
<span class="normal"> 568</span>
<span class="normal"> 569</span>
<span class="normal"> 570</span>
<span class="normal"> 571</span>
<span class="normal"> 572</span>
<span class="normal"> 573</span>
<span class="normal"> 574</span>
<span class="normal"> 575</span>
<span class="normal"> 576</span>
<span class="normal"> 577</span>
<span class="normal"> 578</span>
<span class="normal"> 579</span>
<span class="normal"> 580</span>
<span class="normal"> 581</span>
<span class="normal"> 582</span>
<span class="normal"> 583</span>
<span class="normal"> 584</span>
<span class="normal"> 585</span>
<span class="normal"> 586</span>
<span class="normal"> 587</span>
<span class="normal"> 588</span>
<span class="normal"> 589</span>
<span class="normal"> 590</span>
<span class="normal"> 591</span>
<span class="normal"> 592</span>
<span class="normal"> 593</span>
<span class="normal"> 594</span>
<span class="normal"> 595</span>
<span class="normal"> 596</span>
<span class="normal"> 597</span>
<span class="normal"> 598</span>
<span class="normal"> 599</span>
<span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span>
<span class="normal">1323</span>
<span class="normal">1324</span>
<span class="normal">1325</span>
<span class="normal">1326</span>
<span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span>
<span class="normal">1364</span>
<span class="normal">1365</span>
<span class="normal">1366</span>
<span class="normal">1367</span>
<span class="normal">1368</span>
<span class="normal">1369</span>
<span class="normal">1370</span>
<span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span>
<span class="normal">1422</span>
<span class="normal">1423</span>
<span class="normal">1424</span>
<span class="normal">1425</span>
<span class="normal">1426</span>
<span class="normal">1427</span>
<span class="normal">1428</span>
<span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Module</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Module base class.</span>

<span class="sd">    Modules are everything that can be passed to `jx.integrate`, i.e. compartments,</span>
<span class="sd">    branches, cells, and networks.</span>

<span class="sd">    This base class defines the scaffold for all jaxley modules (compartments,</span>
<span class="sd">    branches, cells, networks).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">[</span>
                <span class="s2">&quot;pre_locs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;pre_branch_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;pre_cell_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;post_locs&quot;</span><span class="p">,</span>
                <span class="s2">&quot;post_branch_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;post_cell_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type&quot;</span><span class="p">,</span>
                <span class="s2">&quot;type_ind&quot;</span><span class="p">,</span>
                <span class="s2">&quot;global_pre_comp_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;global_post_comp_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;global_pre_branch_index&quot;</span><span class="p">,</span>
                <span class="s2">&quot;global_post_branch_index&quot;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_branches_in_each_level</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">])]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_syns</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># List of all types of `jx.Synapse`s.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># List of types of all `jx.Channel`s.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># For trainable parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_make_trainable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_trainable_params</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># For recordings.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recordings</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({})</span>

        <span class="c1"># For stimuli or clamps.</span>
        <span class="c1"># E.g. `self.externals = {&quot;v&quot;: zeros(1000,2), &quot;i&quot;: ones(1000, 2)}`</span>
        <span class="c1"># for 1000 timesteps and two compartments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># E.g. `self.external)inds = {&quot;v&quot;: jnp.asarray([0,1]), &quot;i&quot;: jnp.asarray([2,3])}`</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_inds</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># x, y, z coordinates and radius.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># For debugging the solver. Will be empty by default and only filled if</span>
        <span class="c1"># `self._init_morph_for_debugging` is run.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_update_nodes_with_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add xyz coordinates to nodes.&quot;&quot;&quot;</span>
        <span class="n">num_branches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mf">0.5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">,</span>
            <span class="p">(</span><span class="n">num_branches</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">),</span>
            <span class="n">num_branches</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_branches</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="p">)</span>  <span class="c1"># add offset to prevent branch loc overlap</span>
        <span class="n">xp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">v_interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">idcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">idcs</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">xyz</span><span class="o">.</span><span class="n">T</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">)</span><span class="si">}</span><span class="s2"> different channels. Use `.show()` for details.&quot;</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;jx.</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">base_dir</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="fm">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">base_dir</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert the default params of the module (e.g. radius, length).</span>

<span class="sd">        This is run at `__init__()`. It does not deal with channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">param_name</span><span class="p">,</span> <span class="n">param_value</span> <span class="ow">in</span> <span class="n">param_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">param_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">param_value</span>
        <span class="k">for</span> <span class="n">state_name</span><span class="p">,</span> <span class="n">state_value</span> <span class="ow">in</span> <span class="n">state_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">state_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_value</span>

    <span class="k">def</span> <span class="nf">_gather_channels_from_constituents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constituents</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modify `self.channels` and `self.nodes` with channel info from constituents.</span>

<span class="sd">        This is run at `__init__()`. It takes all branches of constituents (e.g.</span>
<span class="sd">        of all branches when the are assembled into a cell) and adds columns to</span>
<span class="sd">        `.nodes` for the relevant channels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">constituents</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">)</span>
        <span class="c1"># Setting columns of channel names to `False` instead of `NaN`.</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">(),</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">to_jax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move `.nodes` to `.jaxnodes`.</span>

<span class="sd">        Before the actual simulation is run (via `jx.integrate`), all parameters of</span>
<span class="sd">        the `jx.Module` are stored in `.nodes` (a `pd.DataFrame`). However, for</span>
<span class="sd">        simulation, these parameters have to be moved to be `jnp.ndarrays` such that</span>
<span class="sd">        they can be processed on GPU/TPU and such that the simulation can be</span>
<span class="sd">        differentiated. `.to_jax()` copies the `.nodes` to `.jaxnodes`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="n">inds</span><span class="p">]</span>

        <span class="c1"># `jaxedges` contains only parameters (no indices).</span>
        <span class="c1"># `jaxedges` contains only non-Nan elements. This is unlike the channels where</span>
        <span class="c1"># we allow parameter sharing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">synapse</span><span class="o">.</span><span class="n">synapse_params</span><span class="p">:</span>
                <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;type_ind&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="n">i</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">condition</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">synapse</span><span class="o">.</span><span class="n">synapse_states</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">condition</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO.</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">channel_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print detailed information about the Module or a view of it.</span>

<span class="sd">        Args:</span>
<span class="sd">            param_names: The names of the parameters to show. If `None`, all parameters</span>
<span class="sd">                are shown. NOT YET IMPLEMENTED.</span>
<span class="sd">            indices: Whether to show the indices of the compartments.</span>
<span class="sd">            params: Whether to show the parameters of the compartments.</span>
<span class="sd">            states: Whether to show the states of the compartments.</span>
<span class="sd">            channel_names: The names of the channels to show. If `None`, all channels are</span>
<span class="sd">                shown.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A `pd.DataFrame` with the requested information.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_show</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">channel_names</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_show</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">param_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">channel_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print detailed information about the entire Module.&quot;&quot;&quot;</span>
        <span class="n">printable_nodes</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
            <span class="n">param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">channel_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channel_names</span><span class="p">:</span>
                <span class="n">printable_nodes</span> <span class="o">=</span> <span class="n">printable_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">printable_nodes</span> <span class="o">=</span> <span class="n">printable_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">param_names</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">printable_nodes</span> <span class="o">=</span> <span class="n">printable_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">state_names</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
                    <span class="n">printable_nodes</span> <span class="o">=</span> <span class="n">printable_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">param_names</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">states</span><span class="p">:</span>
                    <span class="n">printable_nodes</span> <span class="o">=</span> <span class="n">printable_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">state_names</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">,</span> <span class="s2">&quot;branch_index&quot;</span><span class="p">,</span> <span class="s2">&quot;cell_index&quot;</span><span class="p">]:</span>
                <span class="n">printable_nodes</span> <span class="o">=</span> <span class="n">printable_nodes</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">printable_nodes</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">init_conds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize coupling conductances.</span>

<span class="sd">        Args:</span>
<span class="sd">            params: Conductances and morphology parameters, not yet including</span>
<span class="sd">                coupling conductances.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_append_channel_to_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="s2">&quot;jx.Channel&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds channel nodes from constituents to `self.channel_nodes`.&quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>

        <span class="c1"># Channel does not yet exist in the `jx.Module` at all.</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">_name</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># Previous columns do not have the new channel.</span>

        <span class="k">if</span> <span class="n">channel</span><span class="o">.</span><span class="n">current_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">)</span>

        <span class="c1"># Add a binary column that indicates if a channel is present.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Loop over all new parameters, e.g. gNa, eNa.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># Loop over all new parameters, e.g. gNa, eNa.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set parameter of module (or its view) to a new value.</span>

<span class="sd">        Note that this function can not be called within `jax.jit` or `jax.grad`.</span>
<span class="sd">        Instead, it should be used set the parameters of the module **before** the</span>
<span class="sd">        simulation. Use `.data_set()` to set parameters during `jax.jit` or</span>
<span class="sd">        `jax.grad`.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The name of the parameter to set.</span>
<span class="sd">            val: The value to set the parameter to. If it is `jnp.ndarray` then it</span>
<span class="sd">                must be of shape `(len(num_compartments))`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO(@michaeldeistler) should we allow `.set()` for synaptic parameters</span>
        <span class="c1"># without using the `SynapseView`, purely for consistency with `make_trainable`?</span>
        <span class="n">view</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">table_to_update</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">view</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">view</span><span class="p">[</span><span class="n">key</span><span class="p">])]</span>
            <span class="n">table_to_update</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Key not recognized.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">data_set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">param_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set parameter of module (or its view) to a new value within `jit`.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: The name of the parameter to set.</span>
<span class="sd">            val: The value to set the parameter to. If it is `jnp.ndarray` then it</span>
<span class="sd">                must be of shape `(len(num_compartments))`.</span>
<span class="sd">            param_state: State of the setted parameters, internally used such that this</span>
<span class="sd">                function does not modify global state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">param_state</span><span class="o">=</span><span class="n">param_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_data_set</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">val</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">param_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Note: `data_set` does not support arrays for `val`.</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">view</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">view</span><span class="p">[</span><span class="n">key</span><span class="p">])]</span>
            <span class="n">added_param_state</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">{</span>
                    <span class="s2">&quot;indices&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">),</span>
                    <span class="s2">&quot;key&quot;</span><span class="p">:</span> <span class="n">key</span><span class="p">,</span>
                    <span class="s2">&quot;val&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)),</span>
                <span class="p">}</span>
            <span class="p">]</span>
            <span class="k">if</span> <span class="n">param_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">param_state</span> <span class="o">+=</span> <span class="n">added_param_state</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">param_state</span> <span class="o">=</span> <span class="n">added_param_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Key not recognized.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">param_state</span>

    <span class="k">def</span> <span class="nf">make_trainable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">init_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a parameter trainable.</span>

<span class="sd">        If a parameter is made trainable, it will be returned by `get_parameters()`</span>
<span class="sd">        and should then be passed to `jx.integrate(..., params=params)`.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: Name of the parameter to make trainable.</span>
<span class="sd">            init_val: Initial value of the parameter. If `float`, the same value is</span>
<span class="sd">                used for every created parameter. If `list`, the length of the list has</span>
<span class="sd">                to match the number of created parameters. If `None`, the current</span>
<span class="sd">                parameter value is used and if parameter sharing is performed that the</span>
<span class="sd">                current parameter value is averaged over all shared parameters.</span>
<span class="sd">            verbose: Whether to print the number of parameters that are added and the</span>
<span class="sd">                total number of parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span>
        <span class="p">),</span> <span class="s2">&quot;Parameters of synapses can only be made trainable via the `SynapseView`.&quot;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">controlled_by_param</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_make_trainable</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">init_val</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_trainable</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">init_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">allow_make_trainable</span>
        <span class="p">),</span> <span class="s2">&quot;network.cell(&#39;all&#39;).make_trainable() is not supported. Use a for-loop over cells.&quot;</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">view</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">view</span><span class="p">[</span><span class="n">key</span><span class="p">])]</span>
            <span class="n">grouped_view</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;controlled_by_param&quot;</span><span class="p">)</span>
            <span class="c1"># Because of this `x.index.values` we cannot support `make_trainable()` on</span>
            <span class="c1"># the module level for synapse parameters (but only for `SynapseView`).</span>
            <span class="n">inds_of_comps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grouped_view</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>

            <span class="c1"># Sorted inds are only used to infer the correct starting values.</span>
            <span class="n">param_vals</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
                <span class="p">[</span><span class="n">view</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">inds_of_comps</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Parameter </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not recognized.&quot;</span><span class="p">)</span>

        <span class="n">indices_per_param</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">inds_of_comps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices_per_param</span><span class="p">)</span>

        <span class="c1"># Set the value which the trainable parameter should take.</span>
        <span class="n">num_created_parameters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_per_param</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">init_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">init_val</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_created_parameters</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">init_val</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_created_parameters</span>
                <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;len(init_val)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span><span class="si">}</span><span class="s2">, but trying to create </span><span class="si">{</span><span class="n">num_created_parameters</span><span class="si">}</span><span class="s2"> parameters.&quot;</span>
                <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;init_val must a float, list, or None, but it is a </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">init_val</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_params</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">param_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">new_params</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_trainable_params</span> <span class="o">+=</span> <span class="n">num_created_parameters</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Number of newly added trainable parameters: </span><span class="si">{</span><span class="n">num_created_parameters</span><span class="si">}</span><span class="s2">. Total number of trainable parameters: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trainable_params</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete_trainables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all trainable parameters from the module.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_trainable_params</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">add_to_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a view of the module to a group.</span>

<span class="sd">        Groups can then be indexed. For example:</span>
<span class="sd">        ```python</span>
<span class="sd">        net.cell(0).add_to_group(&quot;excitatory&quot;)</span>
<span class="sd">        net.excitatory.set(&quot;radius&quot;, 0.1)</span>
<span class="sd">        ```</span>

<span class="sd">        Args:</span>
<span class="sd">            group_name: The name of the group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`add_to_group()` makes no sense for an entire module.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_to_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">group_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">[</span><span class="n">group_name</span><span class="p">],</span> <span class="n">view</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span>

    <span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all trainable parameters.</span>

<span class="sd">        The returned parameters should be passed to `jx.integrate(..., params=params).</span>

<span class="sd">        Returns:</span>
<span class="sd">            A list of all trainable parameters in the form of</span>
<span class="sd">                [{&quot;gNa&quot;: jnp.array([0.1, 0.2, 0.3])}, ...].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span>

    <span class="k">def</span> <span class="nf">get_all_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pstate</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all parameters (and coupling conductances) needed to simulate.</span>

<span class="sd">        Runs `init_conds()` and return every parameter that is needed to solve the ODE.</span>
<span class="sd">        This includes conductances, radiuses, lengths, axial_resistivities, but also</span>
<span class="sd">        coupling conductances.</span>

<span class="sd">        This is done by first obtaining the current value of every parameter (not only</span>
<span class="sd">        the trainable ones) and then replacing the trainable ones with the value</span>
<span class="sd">        in `trainable_params()`. This function is run within `jx.integrate()`.</span>

<span class="sd">        pstate can be obtained by calling `params_to_pstate()`.</span>
<span class="sd">        ```</span>
<span class="sd">        params = module.get_parameters() # i.e. [0, 1, 2]</span>
<span class="sd">        pstate = params_to_pstate(params, module.indices_set_by_trainables)</span>
<span class="sd">        module.to_jax() # needed for call to module.jaxnodes</span>
<span class="sd">        ```</span>

<span class="sd">        Args:</span>
<span class="sd">            pstate: The state of the trainable parameters. pstate takes the form</span>
<span class="sd">                [{&quot;key&quot;: &quot;gNa&quot;, &quot;indices&quot;: jnp.array([0, 1, 2]), &quot;val&quot;: jnp.array([0.1, 0.2, 0.3])}, ...].</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of all module parameters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">,</span> <span class="s2">&quot;capacitance&quot;</span><span class="p">]:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel_params</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">:</span>
                <span class="n">params</span><span class="p">[</span><span class="n">channel_params</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">channel_params</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">synapse_params</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">synapse_params</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">synapse_params</span><span class="p">]</span>

        <span class="c1"># Override with those parameters set by `.make_trainable()`.</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
            <span class="n">set_param</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>  <span class="c1"># Only parameters, not initial states.</span>
                <span class="c1"># `inds` is of shape `(num_params, num_comps_per_param)`.</span>
                <span class="c1"># `set_param` is of shape `(num_params,)`</span>
                <span class="c1"># We need to unsqueeze `set_param` to make it `(num_params, 1)` for the</span>
                <span class="c1"># `.set()` to work. This is done with `[:, None]`.</span>
                <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">set_param</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>

        <span class="c1"># Compute conductance params and append them.</span>
        <span class="n">cond_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conds</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cond_params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">params</span>

    <span class="k">def</span> <span class="nf">get_states_from_nodes_and_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return states as they are set in the `.nodes` and `.edges` tables.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_jax</span><span class="p">()</span>  <span class="c1"># Create `.jaxnodes` from `.nodes` and `.jaxedges` from `.edges`.</span>
        <span class="n">states</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]}</span>
        <span class="c1"># Join node and edge states into a single state dictionary.</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">channel_states</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">:</span>
                <span class="n">states</span><span class="p">[</span><span class="n">channel_states</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">channel_states</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">synapse_states</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="n">synapse_states</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">synapse_states</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">states</span>

    <span class="k">def</span> <span class="nf">get_all_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">pstate</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the full initial state of the module from jaxnodes and trainables.</span>

<span class="sd">        Args:</span>
<span class="sd">            pstate: The state of the trainable parameters.</span>
<span class="sd">            all_params: All parameters of the module.</span>
<span class="sd">            delta_t: The time step.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A dictionary of all states of the module.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states_from_nodes_and_edges</span><span class="p">()</span>

        <span class="c1"># Override with the initial states set by `.make_trainable()`.</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
            <span class="n">set_param</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>  <span class="c1"># Only initial states, not parameters.</span>
                <span class="c1"># `inds` is of shape `(num_params, num_comps_per_param)`.</span>
                <span class="c1"># `set_param` is of shape `(num_params,)`</span>
                <span class="c1"># We need to unsqueeze `set_param` to make it `(num_params, 1)` for the</span>
                <span class="c1"># `.set()` to work. This is done with `[:, None]`.</span>
                <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">set_param</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>

        <span class="c1"># Add to the states the initial current through every channel.</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_currents</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">all_params</span>
        <span class="p">)</span>

        <span class="c1"># Add to the states the initial current through every synapse.</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_currents</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">,</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">states</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">initialized</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the `Module` is ready to be solved or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialized_syns</span>

    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the module.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_morph</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">init_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize all mechanisms in their steady state.</span>

<span class="sd">        This considers the voltages and parameters of each compartment.</span>

<span class="sd">        Args:</span>
<span class="sd">            delta_t: Passed on to `channel.init_state()`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Update states of the channels.</span>
        <span class="n">channel_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states_from_nodes_and_edges</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]][</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">voltages</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">channel_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">channel_param_names</span><span class="p">:</span>
                <span class="n">channel_params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="n">init_state</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">init_state</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">voltages</span><span class="p">,</span> <span class="n">channel_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">)</span>

            <span class="c1"># `init_state` might not return all channel states. Only the ones that are</span>
            <span class="c1"># returned are updated here.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">init_state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Note that we are overriding `self.nodes` here, but `self.nodes` is</span>
                <span class="c1"># not used above to actually compute the current states (so there are</span>
                <span class="c1"># no issues with overriding states).</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">_init_morph_for_debugging</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Instandiates row and column inds which can be used to solve the voltage eqs.</span>

<span class="sd">        This is important only for expert users who try to modify the solver for the</span>
<span class="sd">        voltage equations. By default, this function is never run.</span>

<span class="sd">        This is useful for debugging the solver because one can use</span>
<span class="sd">        `scipy.linalg.sparse.spsolve` after every step of the solve.</span>

<span class="sd">        Here is the code snippet that can be used for debugging then (to be inserted in</span>
<span class="sd">        `solver_voltage`):</span>
<span class="sd">        ```python</span>
<span class="sd">        from scipy.sparse import csc_matrix</span>
<span class="sd">        from scipy.sparse.linalg import spsolve</span>
<span class="sd">        from jaxley.utils.debug_solver import build_voltage_matrix_elements</span>

<span class="sd">        elements, solve, num_entries, start_ind_for_branchpoints = (</span>
<span class="sd">            build_voltage_matrix_elements(</span>
<span class="sd">                uppers,</span>
<span class="sd">                lowers,</span>
<span class="sd">                diags,</span>
<span class="sd">                solves,</span>
<span class="sd">                branchpoint_conds_children[debug_states[&quot;child_inds&quot;]],</span>
<span class="sd">                branchpoint_conds_parents[debug_states[&quot;par_inds&quot;]],</span>
<span class="sd">                branchpoint_weights_children[debug_states[&quot;child_inds&quot;]],</span>
<span class="sd">                branchpoint_weights_parents[debug_states[&quot;par_inds&quot;]],</span>
<span class="sd">                branchpoint_diags,</span>
<span class="sd">                branchpoint_solves,</span>
<span class="sd">                debug_states[&quot;nseg&quot;],</span>
<span class="sd">                nbranches,</span>
<span class="sd">            )</span>
<span class="sd">        )</span>
<span class="sd">        sparse_matrix = csc_matrix(</span>
<span class="sd">            (elements, (debug_states[&quot;row_inds&quot;], debug_states[&quot;col_inds&quot;])),</span>
<span class="sd">            shape=(num_entries, num_entries),</span>
<span class="sd">        )</span>
<span class="sd">        solution = spsolve(sparse_matrix, solve)</span>
<span class="sd">        solution = solution[:start_ind_for_branchpoints]  # Delete branchpoint voltages.</span>
<span class="sd">        solves = jnp.reshape(solution, (debug_states[&quot;nseg&quot;], nbranches))</span>
<span class="sd">        return solves</span>
<span class="sd">        ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For scipy and jax.scipy.</span>
        <span class="n">row_and_col_inds</span> <span class="o">=</span> <span class="n">compute_morphology_indices</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">num_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;row_inds&quot;</span><span class="p">])</span>
        <span class="n">data_inds</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">indptr</span> <span class="o">=</span> <span class="n">convert_to_csc</span><span class="p">(</span>
            <span class="n">num_elements</span><span class="o">=</span><span class="n">num_elements</span><span class="p">,</span>
            <span class="n">row_ind</span><span class="o">=</span><span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;row_inds&quot;</span><span class="p">],</span>
            <span class="n">col_ind</span><span class="o">=</span><span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;col_inds&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;row_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;row_inds&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;col_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">row_and_col_inds</span><span class="p">[</span><span class="s2">&quot;col_inds&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;data_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;indptr&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">indptr</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;nseg&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;child_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">[</span><span class="s2">&quot;par_inds&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span>

    <span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a recording into the compartment.</span>

<span class="sd">        Args:</span>
<span class="sd">            state: The name of the state to record.</span>
<span class="sd">            verbose: Whether to print number of inserted recordings.&quot;&quot;&quot;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">view</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
        <span class="n">recording_view</span> <span class="o">=</span> <span class="n">view</span><span class="p">[[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">]]</span>
        <span class="n">recording_view</span> <span class="o">=</span> <span class="n">recording_view</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;comp_index&quot;</span><span class="p">:</span> <span class="s2">&quot;rec_index&quot;</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">(</span><span class="n">recording_view</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">recordings</span><span class="p">,</span> <span class="n">view</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span><span class="si">}</span><span class="s2"> recordings. See `.recordings` for details.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete_recordings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all recordings from the module.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({})</span>

    <span class="k">def</span> <span class="nf">stimulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a stimulus into the compartment.</span>

<span class="sd">        current must be a 1d array or have batch dimension of size `(num_compartments, )`</span>
<span class="sd">        or `(1, )`. If 1d, the same stimulus is added to all compartments.</span>

<span class="sd">        This function cannot be run during `jax.jit` and `jax.grad`. Because of this,</span>
<span class="sd">        it should only be used for static stimuli (i.e., stimuli that do not depend</span>
<span class="sd">        on the data and that should not be learned). For stimuli that depend on data</span>
<span class="sd">        (or that should be learned), please use `data_stimulate()`.</span>

<span class="sd">        Args:</span>
<span class="sd">            current: Current in `nA`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_input</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">state_array</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clamp a state to a given value across specified compartments.</span>

<span class="sd">        Args:</span>
<span class="sd">            state_name: The name of the state to clamp.</span>
<span class="sd">            state_array (jnp.nd: Array of values to clamp the state to.</span>
<span class="sd">            verbose : If True, prints details about the clamping.</span>

<span class="sd">        This function sets external states for the compartments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">state_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> is not a recognized state in this module.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_external_input</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_external_input</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">is_multiple</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span> <span class="o">==</span> <span class="n">batch_size</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span> <span class="k">if</span> <span class="n">is_multiple</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">batch_size</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)],</span> <span class="s2">&quot;Number of comps and stimuli do not match.&quot;</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">values</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">view</span><span class="o">.</span><span class="n">comp_index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()]</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">comp_index</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span><span class="si">}</span><span class="s2"> external_states. See `.externals` for details.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">data_stimulate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">current</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">data_stimuli</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a stimulus into the module within jit (or grad).</span>

<span class="sd">        Args:</span>
<span class="sd">            current: Current in `nA`.</span>
<span class="sd">            verbose: Whether or not to print the number of inserted stimuli. `False`</span>
<span class="sd">                by default because this method is meant to be jitted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_stimulate</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">data_stimuli</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_data_stimulate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">current</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">data_stimuli</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]],</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span> <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">is_multiple</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span> <span class="o">==</span> <span class="n">batch_size</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span> <span class="k">if</span> <span class="n">is_multiple</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">batch_size</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)],</span> <span class="s2">&quot;Number of comps and stimuli do not match.&quot;</span>

        <span class="k">if</span> <span class="n">data_stimuli</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">currents</span> <span class="o">=</span> <span class="n">data_stimuli</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">data_stimuli</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">currents</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({})</span>

        <span class="c1"># Same as in `.stimulate()`.</span>
        <span class="k">if</span> <span class="n">currents</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">currents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">currents</span><span class="p">,</span> <span class="n">current</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">currents</span> <span class="o">=</span> <span class="n">current</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">inds</span><span class="p">,</span> <span class="n">view</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Added </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span><span class="si">}</span><span class="s2"> stimuli.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">currents</span><span class="p">,</span> <span class="n">inds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete_stimuli</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all stimuli from the module.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_inds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Channel</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Insert a channel into the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            channel: The channel to insert.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">view</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_channel_to_nodes</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_syns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_syns</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">init_morph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">external_inds</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">externals</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;bwd_euler&quot;</span><span class="p">,</span>
        <span class="n">voltage_solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;jaxley.stone&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;One step of solving the Ordinary Differential Equation.</span>

<span class="sd">        This function is called inside of `integrate` and increments the state of the</span>
<span class="sd">        module by one time step. Calls `_step_channels` and `_step_synapse` to update</span>
<span class="sd">        the states of the channels and synapses using fwd_euler.</span>

<span class="sd">        Args:</span>
<span class="sd">            u: The state of the module. voltages = u[&quot;v&quot;]</span>
<span class="sd">            delta_t: The time step.</span>
<span class="sd">            external_inds: The indices of the external inputs.</span>
<span class="sd">            externals: The external inputs.</span>
<span class="sd">            params: The parameters of the module.</span>
<span class="sd">            solver: The solver to use for the voltages. Either of [&quot;bwd_euler&quot;,</span>
<span class="sd">                &quot;fwd_euler&quot;, &quot;crank_nicolson&quot;].</span>
<span class="sd">            voltage_solver: The tridiagonal solver used to diagonalize the</span>
<span class="sd">                coefficient matrix of the ODE system. Either of [&quot;jaxley.thomas&quot;,</span>
<span class="sd">                &quot;jaxley.stone&quot;].</span>

<span class="sd">        Returns:</span>
<span class="sd">            The updated state of the module.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Extract the voltages</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

        <span class="c1"># Extract the external inputs</span>
        <span class="n">has_current</span> <span class="o">=</span> <span class="s2">&quot;i&quot;</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">i_current</span> <span class="o">=</span> <span class="n">externals</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_current</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
        <span class="n">i_inds</span> <span class="o">=</span> <span class="n">external_inds</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_current</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
        <span class="n">i_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_input</span><span class="p">(</span>
            <span class="n">voltages</span><span class="p">,</span> <span class="n">i_inds</span><span class="p">,</span> <span class="n">i_current</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Step of the channels.</span>
        <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">v_terms</span><span class="p">,</span> <span class="n">const_terms</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_channels</span><span class="p">(</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">params</span>
        <span class="p">)</span>

        <span class="c1"># Step of the synapse.</span>
        <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">syn_v_terms</span><span class="p">,</span> <span class="n">syn_const_terms</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_synapse</span><span class="p">(</span>
            <span class="n">u</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">delta_t</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Clamp for channels and synapses.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]:</span>
                <span class="n">u</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="c1"># Voltage steps.</span>
        <span class="n">cm</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;capacitance&quot;</span><span class="p">]</span>  <span class="c1"># Abbreviation.</span>

        <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;voltages&quot;</span><span class="p">:</span> <span class="n">voltages</span><span class="p">,</span>
            <span class="s2">&quot;voltage_terms&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">v_terms</span> <span class="o">+</span> <span class="n">syn_v_terms</span><span class="p">)</span> <span class="o">/</span> <span class="n">cm</span><span class="p">,</span>
            <span class="s2">&quot;constant_terms&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">const_terms</span> <span class="o">+</span> <span class="n">i_ext</span> <span class="o">+</span> <span class="n">syn_const_terms</span><span class="p">)</span> <span class="o">/</span> <span class="n">cm</span><span class="p">,</span>
            <span class="s2">&quot;coupling_conds_upper&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branch_uppers&quot;</span><span class="p">],</span>
            <span class="s2">&quot;coupling_conds_lower&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branch_lowers&quot;</span><span class="p">],</span>
            <span class="s2">&quot;summed_coupling_conds&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branch_diags&quot;</span><span class="p">],</span>
            <span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">],</span>
            <span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">],</span>
            <span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">],</span>
            <span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">],</span>
            <span class="s2">&quot;par_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
            <span class="s2">&quot;child_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
            <span class="s2">&quot;nbranches&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
            <span class="s2">&quot;solver&quot;</span><span class="p">:</span> <span class="n">voltage_solver</span><span class="p">,</span>
            <span class="s2">&quot;children_in_level&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">children_in_level</span><span class="p">,</span>
            <span class="s2">&quot;parents_in_level&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents_in_level</span><span class="p">,</span>
            <span class="s2">&quot;root_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_group_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">branchpoint_group_inds</span><span class="p">,</span>
            <span class="s2">&quot;debug_states&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;bwd_euler&quot;</span><span class="p">:</span>
            <span class="n">new_voltages</span> <span class="o">=</span> <span class="n">step_voltage_implicit</span><span class="p">(</span><span class="o">**</span><span class="n">solver_kwargs</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">delta_t</span><span class="p">)</span>
            <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_voltages</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;fwd_euler&quot;</span><span class="p">:</span>
            <span class="n">new_voltages</span> <span class="o">=</span> <span class="n">step_voltage_explicit</span><span class="p">(</span><span class="o">**</span><span class="n">solver_kwargs</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">delta_t</span><span class="p">)</span>
            <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_voltages</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;crank_nicolson&quot;</span><span class="p">:</span>
            <span class="c1"># Crank Nicolson advances by half a step of backward and half a step of</span>
            <span class="c1"># forward Euler.</span>
            <span class="n">half_step_delta_t</span> <span class="o">=</span> <span class="n">delta_t</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">half_step_voltages</span> <span class="o">=</span> <span class="n">step_voltage_implicit</span><span class="p">(</span>
                <span class="o">**</span><span class="n">solver_kwargs</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">half_step_delta_t</span>
            <span class="p">)</span>
            <span class="c1"># The forward Euler step in Crank Nicolson can be performed easily as</span>
            <span class="c1"># `V_{n+1} = 2 * V_{n+1/2} - V_n`. See also NEURON book Chapter 4.</span>
            <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">half_step_voltages</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">voltages</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;You specified `solver=</span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s2">`. The only allowed solvers are &quot;</span>
                <span class="s2">&quot;[&#39;bwd_euler&#39;, &#39;fwd_euler&#39;, &#39;crank_nicolson&#39;].&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Clamp for voltages.</span>
        <span class="k">if</span> <span class="s2">&quot;v&quot;</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">external_inds</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">externals</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">u</span>

    <span class="k">def</span> <span class="nf">_step_channels</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">],</span>
        <span class="n">channel_nodes</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;One step of integration of the channels and of computing their current.&quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_channels_state</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">channel_nodes</span><span class="p">,</span> <span class="n">params</span>
        <span class="p">)</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">current_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_currents</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">channel_nodes</span><span class="p">,</span> <span class="n">params</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">current_terms</span>

    <span class="k">def</span> <span class="nf">_step_channels_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">],</span>
        <span class="n">channel_nodes</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;One integration step of the channels.&quot;&quot;&quot;</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

        <span class="n">query</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">d</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">idcs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">idcs</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">keys</span><span class="p">)))</span>
        <span class="p">)</span>  <span class="c1"># get dict with subset of keys and values from d</span>
        <span class="c1"># only loops over necessary keys, as opposed to looping over d.items()</span>

        <span class="c1"># Update states of the channels.</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">)</span>
            <span class="n">channel_param_names</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">]</span>
            <span class="n">channel_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">)</span>
            <span class="n">channel_state_names</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span>
            <span class="n">channel_indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">channel_nodes</span><span class="p">[</span><span class="n">channel</span><span class="o">.</span><span class="n">_name</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)]</span>

            <span class="n">channel_params</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">channel_param_names</span><span class="p">,</span> <span class="n">channel_indices</span><span class="p">)</span>
            <span class="n">channel_states</span> <span class="o">=</span> <span class="n">query</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">channel_state_names</span><span class="p">,</span> <span class="n">channel_indices</span><span class="p">)</span>

            <span class="n">states_updated</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">update_states</span><span class="p">(</span>
                <span class="n">channel_states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">voltages</span><span class="p">[</span><span class="n">channel_indices</span><span class="p">],</span> <span class="n">channel_params</span>
            <span class="p">)</span>
            <span class="c1"># Rebuild state. This has to be done within the loop over channels to allow</span>
            <span class="c1"># multiple channels which modify the same state.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">states_updated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">channel_indices</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">states</span>

    <span class="k">def</span> <span class="nf">_channel_currents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">],</span>
        <span class="n">channel_nodes</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the current through each channel.</span>

<span class="sd">        This is also updates `state` because the `state` also contains the current.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

        <span class="c1"># Compute current through channels.</span>
        <span class="n">voltage_terms</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>
        <span class="n">constant_terms</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>
        <span class="c1"># Run with two different voltages that are `diff` apart to infer the slope and</span>
        <span class="c1"># offset.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e-3</span>

        <span class="n">current_states</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
            <span class="n">current_states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
            <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">channel_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]][</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="n">channel_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">channel_param_names</span><span class="p">:</span>
                <span class="n">channel_params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">channel_params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">channel_params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">channel_params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>

            <span class="n">channel_states</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">channel_state_names</span><span class="p">:</span>
                <span class="n">channel_states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span>

            <span class="n">v_and_perturbed</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">voltages</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">voltages</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">])</span>
            <span class="n">membrane_currents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">compute_current</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))(</span>
                <span class="n">channel_states</span><span class="p">,</span> <span class="n">v_and_perturbed</span><span class="p">,</span> <span class="n">channel_params</span>
            <span class="p">)</span>
            <span class="n">voltage_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">membrane_currents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">membrane_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">diff</span>
            <span class="n">constant_term</span> <span class="o">=</span> <span class="n">membrane_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">voltage_term</span> <span class="o">*</span> <span class="n">voltages</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">voltage_terms</span> <span class="o">=</span> <span class="n">voltage_terms</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">voltage_term</span><span class="p">)</span>
            <span class="n">constant_terms</span> <span class="o">=</span> <span class="n">constant_terms</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="o">-</span><span class="n">constant_term</span><span class="p">)</span>

            <span class="c1"># Save the current (for the unperturbed voltage) as a state that will</span>
            <span class="c1"># also be passed to the state update.</span>
            <span class="n">current_states</span><span class="p">[</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">current_states</span><span class="p">[</span><span class="n">channel</span><span class="o">.</span><span class="n">current_name</span><span class="p">]</span>
                <span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
                <span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">membrane_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="c1"># Copy the currents into the `state` dictionary such that they can be</span>
        <span class="c1"># recorded and used by `Channel.update_states()`.</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">membrane_current_names</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_states</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="p">(</span><span class="n">voltage_terms</span><span class="p">,</span> <span class="n">constant_terms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_synapse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">u</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">syn_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Channel</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;One step of integration of the channels.</span>

<span class="sd">        `Network` overrides this method (because it actually has synapses), whereas</span>
<span class="sd">        `Compartment`, `Branch`, and `Cell` do not override this.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_synapse_currents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">syn_channels</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_external_input</span><span class="p">(</span>
        <span class="n">voltages</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">i_inds</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">i_stim</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">length_single_compartment</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return external input to each compartment in uA / cm^2.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltages: mV.</span>
<span class="sd">            i_stim: nA.</span>
<span class="sd">            radius: um.</span>
<span class="sd">            length_single_compartment: um.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">zero_vec</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">convert_point_process_to_distributed</span><span class="p">(</span>
            <span class="n">i_stim</span><span class="p">,</span> <span class="n">radius</span><span class="p">[</span><span class="n">i_inds</span><span class="p">],</span> <span class="n">length_single_compartment</span><span class="p">[</span><span class="n">i_inds</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">dnums</span> <span class="o">=</span> <span class="n">ScatterDimensionNumbers</span><span class="p">(</span>
            <span class="n">update_window_dims</span><span class="o">=</span><span class="p">(),</span>
            <span class="n">inserted_window_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
            <span class="n">scatter_dims_to_operand_dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span>
        <span class="p">)</span>
        <span class="n">stim_at_timestep</span> <span class="o">=</span> <span class="n">scatter_add</span><span class="p">(</span><span class="n">zero_vec</span><span class="p">,</span> <span class="n">i_inds</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">current</span><span class="p">,</span> <span class="n">dnums</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stim_at_timestep</span>

    <span class="k">def</span> <span class="nf">vis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;line&quot;</span><span class="p">,</span>
        <span class="n">morph_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Visualize the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            ax: An axis into which to plot.</span>
<span class="sd">            col: The color for all branches.</span>
<span class="sd">            dims: Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of</span>
<span class="sd">                two of them.</span>
<span class="sd">            morph_plot_kwargs: Keyword arguments passed to the plotting function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span><span class="p">(</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="n">view</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
            <span class="n">morph_plot_kwargs</span><span class="o">=</span><span class="n">morph_plot_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_vis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Axes</span><span class="p">,</span>
        <span class="n">col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">morph_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
        <span class="n">branches_inds</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">branch_ind</span> <span class="ow">in</span> <span class="n">branches_inds</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">branch_ind</span><span class="p">][:,</span> <span class="n">dims</span><span class="p">])</span>
            <span class="p">),</span> <span class="s2">&quot;No coordinates available. Use `vis(detail=&#39;point&#39;)` or run `.compute_xyz()` before running `.vis()`.&quot;</span>
            <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">branch_ind</span><span class="p">])</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_morph</span><span class="p">(</span>
            <span class="n">coords</span><span class="p">,</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
            <span class="n">morph_plot_kwargs</span><span class="o">=</span><span class="n">morph_plot_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">morph_plot_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scatter visualization (used only for compartments).&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">view</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Scatter only deals with compartments.&quot;</span>
        <span class="n">branch_ind</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="n">comp_ind</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">branch_ind</span><span class="p">][:,</span> <span class="n">dims</span><span class="p">])</span>
        <span class="p">),</span> <span class="s2">&quot;No coordinates available. Use `vis(detail=&#39;point&#39;)` or run `.compute_xyz()` before running `.vis()`.&quot;</span>

        <span class="n">comp_fraction</span> <span class="o">=</span> <span class="n">loc_of_index</span><span class="p">(</span><span class="n">comp_ind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">)</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">branch_ind</span><span class="p">]</span>
        <span class="n">interpolated_xyz</span> <span class="o">=</span> <span class="n">interpolate_xyz</span><span class="p">(</span><span class="n">comp_fraction</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">plot_morph</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="n">interpolated_xyz</span><span class="p">]]),</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;scatter&quot;</span><span class="p">,</span>
            <span class="n">morph_plot_kwargs</span><span class="o">=</span><span class="n">morph_plot_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">compute_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return xyz coordinates of every branch, based on the branch length.</span>

<span class="sd">        This function should not be called if the morphology was read from an `.swc`</span>
<span class="sd">        file. However, for morphologies that were constructed from scratch, this</span>
<span class="sd">        function **must** be called before `.vis()`. The computed `xyz` coordinates</span>
<span class="sd">        are only used for plotting.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">max_y_multiplier</span> <span class="o">=</span> <span class="mf">5.0</span>
        <span class="n">min_y_multiplier</span> <span class="o">=</span> <span class="mf">0.5</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>
        <span class="n">num_children</span> <span class="o">=</span> <span class="n">_compute_num_children</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="n">index_of_child</span> <span class="o">=</span> <span class="n">_compute_index_of_child</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="n">compute_levels</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>

        <span class="c1"># Extract branch.</span>
        <span class="n">inds_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;branch_index&quot;</span><span class="p">)[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">branch_lens</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds_branch</span><span class="p">]</span>
        <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Different levels will get a different &quot;angle&quot; at which the children emerge from</span>
        <span class="c1"># the parents. This angle is defined by the `y_offset_multiplier`. This value</span>
        <span class="c1"># defines the range between y-location of the first and of the last child of a</span>
        <span class="c1"># parent.</span>
        <span class="n">y_offset_multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">max_y_multiplier</span><span class="p">,</span> <span class="n">min_y_multiplier</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">):</span>
            <span class="c1"># For networks with mixed SWC and from-scatch neurons, only update those</span>
            <span class="c1"># branches that do not have coordingates yet.</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">start_point</span> <span class="o">=</span> <span class="n">endpoints</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="n">num_children_of_parent</span> <span class="o">=</span> <span class="n">num_children</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="k">if</span> <span class="n">num_children_of_parent</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="p">((</span><span class="n">index_of_child</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_children_of_parent</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mf">0.5</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">y_offset_multiplier</span><span class="p">[</span><span class="n">levels</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">start_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>

                <span class="n">len_of_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_offset</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

                <span class="n">end_point</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">start_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_lens</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">len_of_path</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span>
                    <span class="n">start_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_lens</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">len_of_path</span> <span class="o">*</span> <span class="n">y_offset</span><span class="p">,</span>
                    <span class="n">start_point</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="p">]</span>
                <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_point</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">start_point</span><span class="p">,</span> <span class="n">end_point</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Dummy to keey the index `endpoints[parent[b]]` above working.</span>
                <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,)))</span>

    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move cells or networks by adding to their (x, y, z) coordinates.</span>

<span class="sd">        This function is used only for visualization. It does not affect the simulation.</span>

<span class="sd">        Args:</span>
<span class="sd">            x: The amount to move in the x direction in um.</span>
<span class="sd">            y: The amount to move in the y direction in um.</span>
<span class="sd">            z: The amount to move in the z direction in um.</span>
<span class="sd">            update_nodes: Whether `.nodes` should be updated or not. Setting this to</span>
<span class="sd">                `False` largely speeds up moving, especially for big networks, but</span>
<span class="sd">                `.nodes` or `.show` will not show the new xyz coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="c1"># Need to cast to set because this will return one columnn per compartment,</span>
        <span class="c1"># not one column per branch.</span>
        <span class="n">indizes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indizes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">y</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">z</span>
        <span class="k">if</span> <span class="n">update_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_nodes_with_xyz</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">move_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move cells or networks to a location (x, y, z).</span>

<span class="sd">        If x, y, and z are floats, then the first compartment of the first branch</span>
<span class="sd">        of the first cell is moved to that float coordinate, and everything else is</span>
<span class="sd">        shifted by the difference between that compartment&#39;s previous coordinate and</span>
<span class="sd">        the new float location.</span>

<span class="sd">        If x, y, and z are arrays, then they must each have a length equal to the number</span>
<span class="sd">        of cells being moved. Then the first compartment of the first branch of each</span>
<span class="sd">        cell is moved to the specified location.</span>

<span class="sd">        Args:</span>
<span class="sd">            update_nodes: Whether `.nodes` should be updated or not. Setting this to</span>
<span class="sd">                `False` largely speeds up moving, especially for big networks, but</span>
<span class="sd">                `.nodes` or `.show` will not show the new xyz coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_move_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_move_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
        <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Test if any coordinate values are NaN which would greatly affect moving</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;NaN coordinate values detected. Shift amounts cannot be computed. Please run compute_xyzr() or assign initial coordinate values.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get the indices of the cells and branches to move</span>
        <span class="n">cell_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">cell_index</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="n">branch_inds</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">branch_index</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_inds</span><span class="p">),)</span>
            <span class="p">),</span> <span class="s2">&quot;x, y, and z array shapes are not all equal to the number of cells to be moved.&quot;</span>

            <span class="c1"># Split the branches by cell id</span>
            <span class="n">tup_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">view</span><span class="o">.</span><span class="n">cell_index</span><span class="p">,</span> <span class="n">view</span><span class="o">.</span><span class="n">branch_index</span><span class="p">])</span>
            <span class="n">view_cell_branch_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tup_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">branch_split_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">view_cell_branch_inds</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">branches_by_cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span>
                <span class="n">view</span><span class="o">.</span><span class="n">branch_index</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span> <span class="n">branch_split_inds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">)</span>

            <span class="c1"># Calculate the amount to shift all of the branches of each cell</span>
            <span class="n">shift_amounts</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">cell_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Treat as if all branches belong to the same cell to be moved</span>
            <span class="n">branches_by_cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">branch_inds</span><span class="p">]</span>
            <span class="c1"># Calculate the amount to shift all branches by the 1st branch of 1st cell</span>
            <span class="n">shift_amounts</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span> <span class="o">-</span> <span class="bp">self</span><span class="p">[</span><span class="n">cell_inds</span><span class="p">]</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]]</span>

        <span class="c1"># Move all of the branches</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">branches</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">branches_by_cell</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">branches</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">shift_amounts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">update_nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_nodes_with_xyz</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rotate jaxley modules clockwise. Used only for visualization.</span>

<span class="sd">        This function is used only for visualization. It does not affect the simulation.</span>

<span class="sd">        Args:</span>
<span class="sd">            degrees: How many degrees to rotate the module by.</span>
<span class="sd">            rotation_axis: Either of {`xy` | `xz` | `yz`}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rotate</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="o">=</span><span class="n">rotation_axis</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">view</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
        <span class="n">degrees</span> <span class="o">=</span> <span class="n">degrees</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">if</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;xz&quot;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">rotation_axis</span> <span class="o">==</span> <span class="s2">&quot;yz&quot;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>

        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">degrees</span><span class="p">)],</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">degrees</span><span class="p">)]]</span>
        <span class="p">)</span>
        <span class="n">indizes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indizes</span><span class="p">:</span>
            <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">dims</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">i</span><span class="p">][:,</span> <span class="n">dims</span><span class="p">]</span> <span class="o">=</span> <span class="n">rot</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the number of submodules contained in a module.</span>

<span class="sd">        ```</span>
<span class="sd">        network.shape = (num_cells, num_branches, num_compartments)</span>
<span class="sd">        cell.shape = (num_branches, num_compartments)</span>
<span class="sd">        branch.shape = (num_compartments,)</span>
<span class="sd">        ```&quot;&quot;&quot;</span>
        <span class="n">mod_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="s2">&quot;comp&quot;</span> <span class="ow">in</span> <span class="n">mod_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">elif</span> <span class="s2">&quot;branch&quot;</span> <span class="ow">in</span> <span class="n">mod_name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[:]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[:]</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_getitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_getitem</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">module</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Module&quot;</span><span class="p">,</span> <span class="s2">&quot;View&quot;</span><span class="p">],</span>
        <span class="n">index</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">child_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;View&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return View which is created from indexing the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            module: The module to be indexed. Will be a `Module` if `._getitem` is</span>
<span class="sd">                called from `__getitem__` in a `Module` and will be a `View` if it was</span>
<span class="sd">                called from `__getitem__` in a `View`.</span>
<span class="sd">            index: The index (or indices) to index the module.</span>
<span class="sd">            child_name: If passed, this will be the key that is used to index the</span>
<span class="sd">                `module`, e.g. if it is the string `branch` then we will try to call</span>
<span class="sd">                `module.xyz(index)`. If `None` then we try to infer automatically what</span>
<span class="sd">                the childview should be, given the name of the `module`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            An indexed `View`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">childview</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">child_name</span><span class="p">)[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
            <span class="k">return</span> <span class="n">childview</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">child_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">childview</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">child_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_local_inds_to_global</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">cell_inds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">branch_inds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">comp_inds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given local inds of cell, branch, and comp, return the global comp index.&quot;&quot;&quot;</span>
        <span class="n">global_ind</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span><span class="p">[</span><span class="n">cell_inds</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_inds</span>
        <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">+</span> <span class="n">comp_inds</span>
        <span class="k">return</span> <span class="n">global_ind</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="jaxley.modules.base.Module.initialized" class="doc doc-heading">
            <code class=" language-python"><span class="n">initialized</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#jaxley.modules.base.Module.initialized" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Whether the <code>Module</code> is ready to be solved or not.</p>
    </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="jaxley.modules.base.Module.shape" class="doc doc-heading">
            <code class=" language-python"><span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

<a href="#jaxley.modules.base.Module.shape" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Returns the number of submodules contained in a module.</p>
<div class="highlight"><pre><span></span><code>network.shape = (num_cells, num_branches, num_compartments)
cell.shape = (num_branches, num_compartments)
branch.shape = (num_compartments,)
</code></pre></div>
    </div>

</div>



<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.add_to_group" class="doc doc-heading">
            <code class=" language-python"><span class="n">add_to_group</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.add_to_group" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Add a view of the module to a group.</p>
<p>Groups can then be indexed. For example:
<div class="highlight"><pre><span></span><code><span class="n">net</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">add_to_group</span><span class="p">(</span><span class="s2">&quot;excitatory&quot;</span><span class="p">)</span>
<span class="n">net</span><span class="o">.</span><span class="n">excitatory</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
</code></pre></div></p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>group_name</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the group.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">add_to_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a view of the module to a group.</span>

<span class="sd">    Groups can then be indexed. For example:</span>
<span class="sd">    ```python</span>
<span class="sd">    net.cell(0).add_to_group(&quot;excitatory&quot;)</span>
<span class="sd">    net.excitatory.set(&quot;radius&quot;, 0.1)</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">        group_name: The name of the group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`add_to_group()` makes no sense for an entire module.&quot;</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.clamp" class="doc doc-heading">
            <code class=" language-python"><span class="n">clamp</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.clamp" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Clamp a state to a given value across specified compartments.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>state_name</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the state to clamp.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>state_array</code></td>
            <td>
                  <code><span title="jax.numpy.nd">nd</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Array of values to clamp the state to.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, prints details about the clamping.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>
        <p>This function sets external states for the compartments.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">clamp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">state_array</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clamp a state to a given value across specified compartments.</span>

<span class="sd">    Args:</span>
<span class="sd">        state_name: The name of the state to clamp.</span>
<span class="sd">        state_array (jnp.nd: Array of values to clamp the state to.</span>
<span class="sd">        verbose : If True, prints details about the clamping.</span>

<span class="sd">    This function sets external states for the compartments.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">state_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state_name</span><span class="si">}</span><span class="s2"> is not a recognized state in this module.&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_external_input</span><span class="p">(</span><span class="n">state_name</span><span class="p">,</span> <span class="n">state_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.compute_xyz" class="doc doc-heading">
            <code class=" language-python"><span class="n">compute_xyz</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.compute_xyz" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return xyz coordinates of every branch, based on the branch length.</p>
<p>This function should not be called if the morphology was read from an <code>.swc</code>
file. However, for morphologies that were constructed from scratch, this
function <strong>must</strong> be called before <code>.vis()</code>. The computed <code>xyz</code> coordinates
are only used for plotting.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">compute_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return xyz coordinates of every branch, based on the branch length.</span>

<span class="sd">    This function should not be called if the morphology was read from an `.swc`</span>
<span class="sd">    file. However, for morphologies that were constructed from scratch, this</span>
<span class="sd">    function **must** be called before `.vis()`. The computed `xyz` coordinates</span>
<span class="sd">    are only used for plotting.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_y_multiplier</span> <span class="o">=</span> <span class="mf">5.0</span>
    <span class="n">min_y_multiplier</span> <span class="o">=</span> <span class="mf">0.5</span>

    <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>
    <span class="n">num_children</span> <span class="o">=</span> <span class="n">_compute_num_children</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
    <span class="n">index_of_child</span> <span class="o">=</span> <span class="n">_compute_index_of_child</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
    <span class="n">levels</span> <span class="o">=</span> <span class="n">compute_levels</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>

    <span class="c1"># Extract branch.</span>
    <span class="n">inds_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;branch_index&quot;</span><span class="p">)[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">branch_lens</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inds_branch</span><span class="p">]</span>
    <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Different levels will get a different &quot;angle&quot; at which the children emerge from</span>
    <span class="c1"># the parents. This angle is defined by the `y_offset_multiplier`. This value</span>
    <span class="c1"># defines the range between y-location of the first and of the last child of a</span>
    <span class="c1"># parent.</span>
    <span class="n">y_offset_multiplier</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="n">max_y_multiplier</span><span class="p">,</span> <span class="n">min_y_multiplier</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">):</span>
        <span class="c1"># For networks with mixed SWC and from-scatch neurons, only update those</span>
        <span class="c1"># branches that do not have coordingates yet.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">])):</span>
            <span class="k">if</span> <span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">start_point</span> <span class="o">=</span> <span class="n">endpoints</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                <span class="n">num_children_of_parent</span> <span class="o">=</span> <span class="n">num_children</span><span class="p">[</span><span class="n">parents</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">num_children_of_parent</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="p">((</span><span class="n">index_of_child</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">num_children_of_parent</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span> <span class="o">-</span> <span class="mf">0.5</span>
                    <span class="p">)</span> <span class="o">*</span> <span class="n">y_offset_multiplier</span><span class="p">[</span><span class="n">levels</span><span class="p">[</span><span class="n">b</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start_point</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y_offset</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="n">len_of_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">y_offset</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

            <span class="n">end_point</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">start_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_lens</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">len_of_path</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">,</span>
                <span class="n">start_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">branch_lens</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">/</span> <span class="n">len_of_path</span> <span class="o">*</span> <span class="n">y_offset</span><span class="p">,</span>
                <span class="n">start_point</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="p">]</span>
            <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end_point</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">b</span><span class="p">][:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">start_point</span><span class="p">,</span> <span class="n">end_point</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Dummy to keey the index `endpoints[parent[b]]` above working.</span>
            <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,)))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.data_set" class="doc doc-heading">
            <code class=" language-python"><span class="n">data_set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">param_state</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.data_set" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Set parameter of module (or its view) to a new value within <code>jit</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>key</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the parameter to set.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>val</code></td>
            <td>
                  <code><span title="typing.Union">Union</span>[float, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The value to set the parameter to. If it is <code>jnp.ndarray</code> then it
must be of shape <code>(len(num_compartments))</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>param_state</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>State of the setted parameters, internally used such that this
function does not modify global state.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">data_set</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">param_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">]],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set parameter of module (or its view) to a new value within `jit`.</span>

<span class="sd">    Args:</span>
<span class="sd">        key: The name of the parameter to set.</span>
<span class="sd">        val: The value to set the parameter to. If it is `jnp.ndarray` then it</span>
<span class="sd">            must be of shape `(len(num_compartments))`.</span>
<span class="sd">        param_state: State of the setted parameters, internally used such that this</span>
<span class="sd">            function does not modify global state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">view</span> <span class="o">=</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span>
        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">param_state</span><span class="o">=</span><span class="n">param_state</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.data_stimulate" class="doc doc-heading">
            <code class=" language-python"><span class="n">data_stimulate</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">data_stimuli</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.data_stimulate" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Insert a stimulus into the module within jit (or grad).</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>current</code></td>
            <td>
                  <code><span title="jax.numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Current in <code>nA</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether or not to print the number of inserted stimuli. <code>False</code>
by default because this method is meant to be jitted.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">data_stimulate</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">current</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">data_stimuli</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert a stimulus into the module within jit (or grad).</span>

<span class="sd">    Args:</span>
<span class="sd">        current: Current in `nA`.</span>
<span class="sd">        verbose: Whether or not to print the number of inserted stimuli. `False`</span>
<span class="sd">            by default because this method is meant to be jitted.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_stimulate</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">data_stimuli</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete_recordings" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete_recordings</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.delete_recordings" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Removes all recordings from the module.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">delete_recordings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes all recordings from the module.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">recordings</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">({})</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete_stimuli" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete_stimuli</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.delete_stimuli" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Removes all stimuli from the module.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">delete_stimuli</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes all stimuli from the module.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">externals</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">external_inds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.delete_trainables" class="doc doc-heading">
            <code class=" language-python"><span class="n">delete_trainables</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.delete_trainables" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Removes all trainable parameters from the module.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">delete_trainables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Removes all trainable parameters from the module.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">indices_set_by_trainables</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_trainable_params</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.get_all_parameters" class="doc doc-heading">
            <code class=" language-python"><span class="n">get_all_parameters</span><span class="p">(</span><span class="n">pstate</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.get_all_parameters" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return all parameters (and coupling conductances) needed to simulate.</p>
<p>Runs <code>init_conds()</code> and return every parameter that is needed to solve the ODE.
This includes conductances, radiuses, lengths, axial_resistivities, but also
coupling conductances.</p>
<p>This is done by first obtaining the current value of every parameter (not only
the trainable ones) and then replacing the trainable ones with the value
in <code>trainable_params()</code>. This function is run within <code>jx.integrate()</code>.</p>
<p>pstate can be obtained by calling <code>params_to_pstate()</code>.
<div class="highlight"><pre><span></span><code>params = module.get_parameters() # i.e. [0, 1, 2]
pstate = params_to_pstate(params, module.indices_set_by_trainables)
module.to_jax() # needed for call to module.jaxnodes
</code></pre></div></p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>pstate</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The state of the trainable parameters. pstate takes the form
[{&ldquo;key&rdquo;: &ldquo;gNa&rdquo;, &ldquo;indices&rdquo;: jnp.array([0, 1, 2]), &ldquo;val&rdquo;: jnp.array([0.1, 0.2, 0.3])}, &hellip;].</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of all module parameters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_all_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pstate</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all parameters (and coupling conductances) needed to simulate.</span>

<span class="sd">    Runs `init_conds()` and return every parameter that is needed to solve the ODE.</span>
<span class="sd">    This includes conductances, radiuses, lengths, axial_resistivities, but also</span>
<span class="sd">    coupling conductances.</span>

<span class="sd">    This is done by first obtaining the current value of every parameter (not only</span>
<span class="sd">    the trainable ones) and then replacing the trainable ones with the value</span>
<span class="sd">    in `trainable_params()`. This function is run within `jx.integrate()`.</span>

<span class="sd">    pstate can be obtained by calling `params_to_pstate()`.</span>
<span class="sd">    ```</span>
<span class="sd">    params = module.get_parameters() # i.e. [0, 1, 2]</span>
<span class="sd">    pstate = params_to_pstate(params, module.indices_set_by_trainables)</span>
<span class="sd">    module.to_jax() # needed for call to module.jaxnodes</span>
<span class="sd">    ```</span>

<span class="sd">    Args:</span>
<span class="sd">        pstate: The state of the trainable parameters. pstate takes the form</span>
<span class="sd">            [{&quot;key&quot;: &quot;gNa&quot;, &quot;indices&quot;: jnp.array([0, 1, 2]), &quot;val&quot;: jnp.array([0.1, 0.2, 0.3])}, ...].</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary of all module parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">params</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">,</span> <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">,</span> <span class="s2">&quot;capacitance&quot;</span><span class="p">]:</span>
        <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">channel_params</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="p">:</span>
            <span class="n">params</span><span class="p">[</span><span class="n">channel_params</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">channel_params</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">synapse_params</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="n">synapse_params</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">synapse_params</span><span class="p">]</span>

    <span class="c1"># Override with those parameters set by `.make_trainable()`.</span>
    <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
        <span class="n">set_param</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>  <span class="c1"># Only parameters, not initial states.</span>
            <span class="c1"># `inds` is of shape `(num_params, num_comps_per_param)`.</span>
            <span class="c1"># `set_param` is of shape `(num_params,)`</span>
            <span class="c1"># We need to unsqueeze `set_param` to make it `(num_params, 1)` for the</span>
            <span class="c1"># `.set()` to work. This is done with `[:, None]`.</span>
            <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">set_param</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>

    <span class="c1"># Compute conductance params and append them.</span>
    <span class="n">cond_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conds</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">cond_params</span><span class="p">:</span>
        <span class="n">params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cond_params</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">params</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.get_all_states" class="doc doc-heading">
            <code class=" language-python"><span class="n">get_all_states</span><span class="p">(</span><span class="n">pstate</span><span class="p">,</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.get_all_states" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Get the full initial state of the module from jaxnodes and trainables.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>pstate</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The state of the trainable parameters.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>all_params</code></td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>All parameters of the module.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>delta_t</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The time step.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary of all states of the module.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_all_states</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">pstate</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">],</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the full initial state of the module from jaxnodes and trainables.</span>

<span class="sd">    Args:</span>
<span class="sd">        pstate: The state of the trainable parameters.</span>
<span class="sd">        all_params: All parameters of the module.</span>
<span class="sd">        delta_t: The time step.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A dictionary of all states of the module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states_from_nodes_and_edges</span><span class="p">()</span>

    <span class="c1"># Override with the initial states set by `.make_trainable()`.</span>
    <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">pstate</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;indices&quot;</span><span class="p">]</span>
        <span class="n">set_param</span> <span class="o">=</span> <span class="n">parameter</span><span class="p">[</span><span class="s2">&quot;val&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>  <span class="c1"># Only initial states, not parameters.</span>
            <span class="c1"># `inds` is of shape `(num_params, num_comps_per_param)`.</span>
            <span class="c1"># `set_param` is of shape `(num_params,)`</span>
            <span class="c1"># We need to unsqueeze `set_param` to make it `(num_params, 1)` for the</span>
            <span class="c1"># `.set()` to work. This is done with `[:, None]`.</span>
            <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">set_param</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span>

    <span class="c1"># Add to the states the initial current through every channel.</span>
    <span class="n">states</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_currents</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">all_params</span>
    <span class="p">)</span>

    <span class="c1"># Add to the states the initial current through every synapse.</span>
    <span class="n">states</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_currents</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">,</span> <span class="n">all_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">states</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.get_parameters" class="doc doc-heading">
            <code class=" language-python"><span class="n">get_parameters</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.get_parameters" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Get all trainable parameters.</p>
<p>The returned parameters should be passed to `jx.integrate(&hellip;, params=params).</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.List">List</span>[<span title="typing.Dict">Dict</span>[str, <span title="jax.numpy.ndarray">ndarray</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of all trainable parameters in the form of
[{&ldquo;gNa&rdquo;: jnp.array([0.1, 0.2, 0.3])}, &hellip;].</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get all trainable parameters.</span>

<span class="sd">    The returned parameters should be passed to `jx.integrate(..., params=params).</span>

<span class="sd">    Returns:</span>
<span class="sd">        A list of all trainable parameters in the form of</span>
<span class="sd">            [{&quot;gNa&quot;: jnp.array([0.1, 0.2, 0.3])}, ...].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">trainable_params</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.get_states_from_nodes_and_edges" class="doc doc-heading">
            <code class=" language-python"><span class="n">get_states_from_nodes_and_edges</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.get_states_from_nodes_and_edges" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Return states as they are set in the <code>.nodes</code> and <code>.edges</code> tables.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_states_from_nodes_and_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return states as they are set in the `.nodes` and `.edges` tables.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">to_jax</span><span class="p">()</span>  <span class="c1"># Create `.jaxnodes` from `.nodes` and `.jaxedges` from `.edges`.</span>
    <span class="n">states</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]}</span>
    <span class="c1"># Join node and edge states into a single state dictionary.</span>
    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">channel_states</span> <span class="ow">in</span> <span class="n">channel</span><span class="o">.</span><span class="n">channel_states</span><span class="p">:</span>
            <span class="n">states</span><span class="p">[</span><span class="n">channel_states</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">channel_states</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">synapse_states</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span><span class="p">:</span>
        <span class="n">states</span><span class="p">[</span><span class="n">synapse_states</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">synapse_states</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">states</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.init_conds" class="doc doc-heading">
            <code class=" language-python"><span class="n">init_conds</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

<a href="#jaxley.modules.base.Module.init_conds" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize coupling conductances.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>params</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Conductances and morphology parameters, not yet including
coupling conductances.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abstractmethod</span>
<span class="k">def</span> <span class="nf">init_conds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize coupling conductances.</span>

<span class="sd">    Args:</span>
<span class="sd">        params: Conductances and morphology parameters, not yet including</span>
<span class="sd">            coupling conductances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.init_states" class="doc doc-heading">
            <code class=" language-python"><span class="n">init_states</span><span class="p">(</span><span class="n">delta_t</span><span class="o">=</span><span class="mf">0.025</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.init_states" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize all mechanisms in their steady state.</p>
<p>This considers the voltages and parameters of each compartment.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>delta_t</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Passed on to <code>channel.init_state()</code>.</p>
              </div>
            </td>
            <td>
                  <code>0.025</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">init_states</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize all mechanisms in their steady state.</span>

<span class="sd">    This considers the voltages and parameters of each compartment.</span>

<span class="sd">    Args:</span>
<span class="sd">        delta_t: Passed on to `channel.init_state()`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Update states of the channels.</span>
    <span class="n">channel_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_states_from_nodes_and_edges</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">_name</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">channel_nodes</span><span class="p">[</span><span class="n">name</span><span class="p">]][</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">channel_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">channel</span><span class="o">.</span><span class="n">channel_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">channel_params</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">channel_param_names</span><span class="p">:</span>
            <span class="n">channel_params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel_nodes</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">init_state</span> <span class="o">=</span> <span class="n">channel</span><span class="o">.</span><span class="n">init_state</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">voltages</span><span class="p">,</span> <span class="n">channel_params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">)</span>

        <span class="c1"># `init_state` might not return all channel states. Only the ones that are</span>
        <span class="c1"># returned are updated here.</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">init_state</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Note that we are overriding `self.nodes` here, but `self.nodes` is</span>
            <span class="c1"># not used above to actually compute the current states (so there are</span>
            <span class="c1"># no issues with overriding states).</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">indices</span><span class="p">,</span> <span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.initialize" class="doc doc-heading">
            <code class=" language-python"><span class="n">initialize</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.initialize" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize the module.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the module.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_morph</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.insert" class="doc doc-heading">
            <code class=" language-python"><span class="n">insert</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.insert" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Insert a channel into the module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>channel</code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jaxley.channels.Channel" href="../mechanisms/#jaxley.channels.channel.Channel">Channel</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The channel to insert.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">:</span> <span class="n">Channel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert a channel into the module.</span>

<span class="sd">    Args:</span>
<span class="sd">        channel: The channel to insert.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_insert</span><span class="p">(</span><span class="n">channel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.make_trainable" class="doc doc-heading">
            <code class=" language-python"><span class="n">make_trainable</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">init_val</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.make_trainable" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Make a parameter trainable.</p>
<p>If a parameter is made trainable, it will be returned by <code>get_parameters()</code>
and should then be passed to <code>jx.integrate(..., params=params)</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>key</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Name of the parameter to make trainable.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>init_val</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[float, list]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Initial value of the parameter. If <code>float</code>, the same value is
used for every created parameter. If <code>list</code>, the length of the list has
to match the number of created parameters. If <code>None</code>, the current
parameter value is used and if parameter sharing is performed that the
current parameter value is averaged over all shared parameters.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to print the number of parameters that are added and the
total number of parameters.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">make_trainable</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">init_val</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">list</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make a parameter trainable.</span>

<span class="sd">    If a parameter is made trainable, it will be returned by `get_parameters()`</span>
<span class="sd">    and should then be passed to `jx.integrate(..., params=params)`.</span>

<span class="sd">    Args:</span>
<span class="sd">        key: Name of the parameter to make trainable.</span>
<span class="sd">        init_val: Initial value of the parameter. If `float`, the same value is</span>
<span class="sd">            used for every created parameter. If `list`, the length of the list has</span>
<span class="sd">            to match the number of created parameters. If `None`, the current</span>
<span class="sd">            parameter value is used and if parameter sharing is performed that the</span>
<span class="sd">            current parameter value is averaged over all shared parameters.</span>
<span class="sd">        verbose: Whether to print the number of parameters that are added and the</span>
<span class="sd">            total number of parameters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span>
    <span class="p">),</span> <span class="s2">&quot;Parameters of synapses can only be made trainable via the `SynapseView`.&quot;</span>
    <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">view</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">controlled_by_param</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_make_trainable</span><span class="p">(</span><span class="n">view</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">init_val</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.move" class="doc doc-heading">
            <code class=" language-python"><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">update_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.move" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Move cells or networks by adding to their (x, y, z) coordinates.</p>
<p>This function is used only for visualization. It does not affect the simulation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>x</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The amount to move in the x direction in um.</p>
              </div>
            </td>
            <td>
                  <code>0.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>y</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The amount to move in the y direction in um.</p>
              </div>
            </td>
            <td>
                  <code>0.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>z</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The amount to move in the z direction in um.</p>
              </div>
            </td>
            <td>
                  <code>0.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>update_nodes</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether <code>.nodes</code> should be updated or not. Setting this to
<code>False</code> largely speeds up moving, especially for big networks, but
<code>.nodes</code> or <code>.show</code> will not show the new xyz coordinates.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">move</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move cells or networks by adding to their (x, y, z) coordinates.</span>

<span class="sd">    This function is used only for visualization. It does not affect the simulation.</span>

<span class="sd">    Args:</span>
<span class="sd">        x: The amount to move in the x direction in um.</span>
<span class="sd">        y: The amount to move in the y direction in um.</span>
<span class="sd">        z: The amount to move in the z direction in um.</span>
<span class="sd">        update_nodes: Whether `.nodes` should be updated or not. Setting this to</span>
<span class="sd">            `False` largely speeds up moving, especially for big networks, but</span>
<span class="sd">            `.nodes` or `.show` will not show the new xyz coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_move</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.move_to" class="doc doc-heading">
            <code class=" language-python"><span class="n">move_to</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">update_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.move_to" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Move cells or networks to a location (x, y, z).</p>
<p>If x, y, and z are floats, then the first compartment of the first branch
of the first cell is moved to that float coordinate, and everything else is
shifted by the difference between that compartment&rsquo;s previous coordinate and
the new float location.</p>
<p>If x, y, and z are arrays, then they must each have a length equal to the number
of cells being moved. Then the first compartment of the first branch of each
cell is moved to the specified location.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>update_nodes</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether <code>.nodes</code> should be updated or not. Setting this to
<code>False</code> largely speeds up moving, especially for big networks, but
<code>.nodes</code> or <code>.show</code> will not show the new xyz coordinates.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">move_to</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">z</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">update_nodes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move cells or networks to a location (x, y, z).</span>

<span class="sd">    If x, y, and z are floats, then the first compartment of the first branch</span>
<span class="sd">    of the first cell is moved to that float coordinate, and everything else is</span>
<span class="sd">    shifted by the difference between that compartment&#39;s previous coordinate and</span>
<span class="sd">    the new float location.</span>

<span class="sd">    If x, y, and z are arrays, then they must each have a length equal to the number</span>
<span class="sd">    of cells being moved. Then the first compartment of the first branch of each</span>
<span class="sd">    cell is moved to the specified location.</span>

<span class="sd">    Args:</span>
<span class="sd">        update_nodes: Whether `.nodes` should be updated or not. Setting this to</span>
<span class="sd">            `False` largely speeds up moving, especially for big networks, but</span>
<span class="sd">            `.nodes` or `.show` will not show the new xyz coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_move_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">update_nodes</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.record" class="doc doc-heading">
            <code class=" language-python"><span class="n">record</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="s1">&#39;v&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.record" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Insert a recording into the compartment.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>state</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the state to record.</p>
              </div>
            </td>
            <td>
                  <code>&#39;v&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>verbose</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to print number of inserted recordings.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">record</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert a recording into the compartment.</span>

<span class="sd">    Args:</span>
<span class="sd">        state: The name of the state to record.</span>
<span class="sd">        verbose: Whether to print number of inserted recordings.&quot;&quot;&quot;</span>
    <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">view</span><span class="p">[</span><span class="s2">&quot;state&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span>
    <span class="n">recording_view</span> <span class="o">=</span> <span class="n">view</span><span class="p">[[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">,</span> <span class="s2">&quot;state&quot;</span><span class="p">]]</span>
    <span class="n">recording_view</span> <span class="o">=</span> <span class="n">recording_view</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;comp_index&quot;</span><span class="p">:</span> <span class="s2">&quot;rec_index&quot;</span><span class="p">})</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_record</span><span class="p">(</span><span class="n">recording_view</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.rotate" class="doc doc-heading">
            <code class=" language-python"><span class="n">rotate</span><span class="p">(</span><span class="n">degrees</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.rotate" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Rotate jaxley modules clockwise. Used only for visualization.</p>
<p>This function is used only for visualization. It does not affect the simulation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>degrees</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>How many degrees to rotate the module by.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>rotation_axis</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Either of {<code>xy</code> | <code>xz</code> | <code>yz</code>}.</p>
              </div>
            </td>
            <td>
                  <code>&#39;xy&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;xy&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Rotate jaxley modules clockwise. Used only for visualization.</span>

<span class="sd">    This function is used only for visualization. It does not affect the simulation.</span>

<span class="sd">    Args:</span>
<span class="sd">        degrees: How many degrees to rotate the module by.</span>
<span class="sd">        rotation_axis: Either of {`xy` | `xz` | `yz`}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_rotate</span><span class="p">(</span><span class="n">degrees</span><span class="o">=</span><span class="n">degrees</span><span class="p">,</span> <span class="n">rotation_axis</span><span class="o">=</span><span class="n">rotation_axis</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.set" class="doc doc-heading">
            <code class=" language-python"><span class="nb">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.set" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Set parameter of module (or its view) to a new value.</p>
<p>Note that this function can not be called within <code>jax.jit</code> or <code>jax.grad</code>.
Instead, it should be used set the parameters of the module <strong>before</strong> the
simulation. Use <code>.data_set()</code> to set parameters during <code>jax.jit</code> or
<code>jax.grad</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>key</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the parameter to set.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>val</code></td>
            <td>
                  <code><span title="typing.Union">Union</span>[float, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The value to set the parameter to. If it is <code>jnp.ndarray</code> then it
must be of shape <code>(len(num_compartments))</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set parameter of module (or its view) to a new value.</span>

<span class="sd">    Note that this function can not be called within `jax.jit` or `jax.grad`.</span>
<span class="sd">    Instead, it should be used set the parameters of the module **before** the</span>
<span class="sd">    simulation. Use `.data_set()` to set parameters during `jax.jit` or</span>
<span class="sd">    `jax.grad`.</span>

<span class="sd">    Args:</span>
<span class="sd">        key: The name of the parameter to set.</span>
<span class="sd">        val: The value to set the parameter to. If it is `jnp.ndarray` then it</span>
<span class="sd">            must be of shape `(len(num_compartments))`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO(@michaeldeistler) should we allow `.set()` for synaptic parameters</span>
    <span class="c1"># without using the `SynapseView`, purely for consistency with `make_trainable`?</span>
    <span class="n">view</span> <span class="o">=</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="ow">or</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span>
        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.show" class="doc doc-heading">
            <code class=" language-python"><span class="n">show</span><span class="p">(</span><span class="n">param_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">channel_names</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.show" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Print detailed information about the Module or a view of it.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>param_names</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[str, <span title="typing.List">List</span>[str]]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The names of the parameters to show. If <code>None</code>, all parameters
are shown. NOT YET IMPLEMENTED.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>indices</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the indices of the compartments.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>params</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the parameters of the compartments.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>states</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to show the states of the compartments.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>channel_names</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[str]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The names of the channels to show. If <code>None</code>, all channels are
shown.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="pandas.DataFrame">DataFrame</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A <code>pd.DataFrame</code> with the requested information.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">show</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">param_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># TODO.</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">states</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">channel_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print detailed information about the Module or a view of it.</span>

<span class="sd">    Args:</span>
<span class="sd">        param_names: The names of the parameters to show. If `None`, all parameters</span>
<span class="sd">            are shown. NOT YET IMPLEMENTED.</span>
<span class="sd">        indices: Whether to show the indices of the compartments.</span>
<span class="sd">        params: Whether to show the parameters of the compartments.</span>
<span class="sd">        states: Whether to show the states of the compartments.</span>
<span class="sd">        channel_names: The names of the channels to show. If `None`, all channels are</span>
<span class="sd">            shown.</span>

<span class="sd">    Returns:</span>
<span class="sd">        A `pd.DataFrame` with the requested information.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_show</span><span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">param_names</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">channel_names</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.step" class="doc doc-heading">
            <code class=" language-python"><span class="n">step</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">external_inds</span><span class="p">,</span> <span class="n">externals</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;bwd_euler&#39;</span><span class="p">,</span> <span class="n">voltage_solver</span><span class="o">=</span><span class="s1">&#39;jaxley.stone&#39;</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.step" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>One step of solving the Ordinary Differential Equation.</p>
<p>This function is called inside of <code>integrate</code> and increments the state of the
module by one time step. Calls <code>_step_channels</code> and <code>_step_synapse</code> to update
the states of the channels and synapses using fwd_euler.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>u</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The state of the module. voltages = u[&ldquo;v&rdquo;]</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>delta_t</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The time step.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>external_inds</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The indices of the external inputs.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>externals</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The external inputs.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>params</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The parameters of the module.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>solver</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The solver to use for the voltages. Either of [&ldquo;bwd_euler&rdquo;,
&ldquo;fwd_euler&rdquo;, &ldquo;crank_nicolson&rdquo;].</p>
              </div>
            </td>
            <td>
                  <code>&#39;bwd_euler&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>voltage_solver</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The tridiagonal solver used to diagonalize the
coefficient matrix of the ODE system. Either of [&ldquo;jaxley.thomas&rdquo;,
&ldquo;jaxley.stone&rdquo;].</p>
              </div>
            </td>
            <td>
                  <code>&#39;jaxley.stone&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The updated state of the module.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">u</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">external_inds</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">externals</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
    <span class="n">solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;bwd_euler&quot;</span><span class="p">,</span>
    <span class="n">voltage_solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;jaxley.stone&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;One step of solving the Ordinary Differential Equation.</span>

<span class="sd">    This function is called inside of `integrate` and increments the state of the</span>
<span class="sd">    module by one time step. Calls `_step_channels` and `_step_synapse` to update</span>
<span class="sd">    the states of the channels and synapses using fwd_euler.</span>

<span class="sd">    Args:</span>
<span class="sd">        u: The state of the module. voltages = u[&quot;v&quot;]</span>
<span class="sd">        delta_t: The time step.</span>
<span class="sd">        external_inds: The indices of the external inputs.</span>
<span class="sd">        externals: The external inputs.</span>
<span class="sd">        params: The parameters of the module.</span>
<span class="sd">        solver: The solver to use for the voltages. Either of [&quot;bwd_euler&quot;,</span>
<span class="sd">            &quot;fwd_euler&quot;, &quot;crank_nicolson&quot;].</span>
<span class="sd">        voltage_solver: The tridiagonal solver used to diagonalize the</span>
<span class="sd">            coefficient matrix of the ODE system. Either of [&quot;jaxley.thomas&quot;,</span>
<span class="sd">            &quot;jaxley.stone&quot;].</span>

<span class="sd">    Returns:</span>
<span class="sd">        The updated state of the module.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Extract the voltages</span>
    <span class="n">voltages</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

    <span class="c1"># Extract the external inputs</span>
    <span class="n">has_current</span> <span class="o">=</span> <span class="s2">&quot;i&quot;</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">i_current</span> <span class="o">=</span> <span class="n">externals</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_current</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
    <span class="n">i_inds</span> <span class="o">=</span> <span class="n">external_inds</span><span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">has_current</span> <span class="k">else</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">)</span>
    <span class="n">i_ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_external_input</span><span class="p">(</span>
        <span class="n">voltages</span><span class="p">,</span> <span class="n">i_inds</span><span class="p">,</span> <span class="n">i_current</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Step of the channels.</span>
    <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">v_terms</span><span class="p">,</span> <span class="n">const_terms</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_channels</span><span class="p">(</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">channels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">params</span>
    <span class="p">)</span>

    <span class="c1"># Step of the synapse.</span>
    <span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">syn_v_terms</span><span class="p">,</span> <span class="n">syn_const_terms</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_synapse</span><span class="p">(</span>
        <span class="n">u</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">,</span>
        <span class="n">params</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Clamp for channels and synapses.</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">]:</span>
            <span class="n">u</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">external_inds</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">externals</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

    <span class="c1"># Voltage steps.</span>
    <span class="n">cm</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;capacitance&quot;</span><span class="p">]</span>  <span class="c1"># Abbreviation.</span>

    <span class="n">solver_kwargs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;voltages&quot;</span><span class="p">:</span> <span class="n">voltages</span><span class="p">,</span>
        <span class="s2">&quot;voltage_terms&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">v_terms</span> <span class="o">+</span> <span class="n">syn_v_terms</span><span class="p">)</span> <span class="o">/</span> <span class="n">cm</span><span class="p">,</span>
        <span class="s2">&quot;constant_terms&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">const_terms</span> <span class="o">+</span> <span class="n">i_ext</span> <span class="o">+</span> <span class="n">syn_const_terms</span><span class="p">)</span> <span class="o">/</span> <span class="n">cm</span><span class="p">,</span>
        <span class="s2">&quot;coupling_conds_upper&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branch_uppers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;coupling_conds_lower&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branch_lowers&quot;</span><span class="p">],</span>
        <span class="s2">&quot;summed_coupling_conds&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branch_diags&quot;</span><span class="p">],</span>
        <span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">],</span>
        <span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">],</span>
        <span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">],</span>
        <span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">:</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">],</span>
        <span class="s2">&quot;par_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
        <span class="s2">&quot;child_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
        <span class="s2">&quot;nbranches&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
        <span class="s2">&quot;solver&quot;</span><span class="p">:</span> <span class="n">voltage_solver</span><span class="p">,</span>
        <span class="s2">&quot;children_in_level&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">children_in_level</span><span class="p">,</span>
        <span class="s2">&quot;parents_in_level&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parents_in_level</span><span class="p">,</span>
        <span class="s2">&quot;root_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_group_inds&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">branchpoint_group_inds</span><span class="p">,</span>
        <span class="s2">&quot;debug_states&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug_states</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;bwd_euler&quot;</span><span class="p">:</span>
        <span class="n">new_voltages</span> <span class="o">=</span> <span class="n">step_voltage_implicit</span><span class="p">(</span><span class="o">**</span><span class="n">solver_kwargs</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">delta_t</span><span class="p">)</span>
        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_voltages</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;fwd_euler&quot;</span><span class="p">:</span>
        <span class="n">new_voltages</span> <span class="o">=</span> <span class="n">step_voltage_explicit</span><span class="p">(</span><span class="o">**</span><span class="n">solver_kwargs</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">delta_t</span><span class="p">)</span>
        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_voltages</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">solver</span> <span class="o">==</span> <span class="s2">&quot;crank_nicolson&quot;</span><span class="p">:</span>
        <span class="c1"># Crank Nicolson advances by half a step of backward and half a step of</span>
        <span class="c1"># forward Euler.</span>
        <span class="n">half_step_delta_t</span> <span class="o">=</span> <span class="n">delta_t</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">half_step_voltages</span> <span class="o">=</span> <span class="n">step_voltage_implicit</span><span class="p">(</span>
            <span class="o">**</span><span class="n">solver_kwargs</span><span class="p">,</span> <span class="n">delta_t</span><span class="o">=</span><span class="n">half_step_delta_t</span>
        <span class="p">)</span>
        <span class="c1"># The forward Euler step in Crank Nicolson can be performed easily as</span>
        <span class="c1"># `V_{n+1} = 2 * V_{n+1/2} - V_n`. See also NEURON book Chapter 4.</span>
        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">half_step_voltages</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="n">voltages</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;You specified `solver=</span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s2">`. The only allowed solvers are &quot;</span>
            <span class="s2">&quot;[&#39;bwd_euler&#39;, &#39;fwd_euler&#39;, &#39;crank_nicolson&#39;].&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Clamp for voltages.</span>
    <span class="k">if</span> <span class="s2">&quot;v&quot;</span> <span class="ow">in</span> <span class="n">externals</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">external_inds</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">externals</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">u</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.stimulate" class="doc doc-heading">
            <code class=" language-python"><span class="n">stimulate</span><span class="p">(</span><span class="n">current</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#jaxley.modules.base.Module.stimulate" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Insert a stimulus into the compartment.</p>
<p>current must be a 1d array or have batch dimension of size <code>(num_compartments, )</code>
or <code>(1, )</code>. If 1d, the same stimulus is added to all compartments.</p>
<p>This function cannot be run during <code>jax.jit</code> and <code>jax.grad</code>. Because of this,
it should only be used for static stimuli (i.e., stimuli that do not depend
on the data and that should not be learned). For stimuli that depend on data
(or that should be learned), please use <code>data_stimulate()</code>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>current</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Current in <code>nA</code>.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">stimulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Insert a stimulus into the compartment.</span>

<span class="sd">    current must be a 1d array or have batch dimension of size `(num_compartments, )`</span>
<span class="sd">    or `(1, )`. If 1d, the same stimulus is added to all compartments.</span>

<span class="sd">    This function cannot be run during `jax.jit` and `jax.grad`. Because of this,</span>
<span class="sd">    it should only be used for static stimuli (i.e., stimuli that do not depend</span>
<span class="sd">    on the data and that should not be learned). For stimuli that depend on data</span>
<span class="sd">    (or that should be learned), please use `data_stimulate()`.</span>

<span class="sd">    Args:</span>
<span class="sd">        current: Current in `nA`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_external_input</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.to_jax" class="doc doc-heading">
            <code class=" language-python"><span class="n">to_jax</span><span class="p">()</span></code>

<a href="#jaxley.modules.base.Module.to_jax" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Move <code>.nodes</code> to <code>.jaxnodes</code>.</p>
<p>Before the actual simulation is run (via <code>jx.integrate</code>), all parameters of
the <code>jx.Module</code> are stored in <code>.nodes</code> (a <code>pd.DataFrame</code>). However, for
simulation, these parameters have to be moved to be <code>jnp.ndarrays</code> such that
they can be processed on GPU/TPU and such that the simulation can be
differentiated. <code>.to_jax()</code> copies the <code>.nodes</code> to <code>.jaxnodes</code>.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">to_jax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Move `.nodes` to `.jaxnodes`.</span>

<span class="sd">    Before the actual simulation is run (via `jx.integrate`), all parameters of</span>
<span class="sd">    the `jx.Module` are stored in `.nodes` (a `pd.DataFrame`). However, for</span>
<span class="sd">    simulation, these parameters have to be moved to be `jnp.ndarrays` such that</span>
<span class="sd">    they can be processed on GPU/TPU and such that the simulation can be</span>
<span class="sd">    differentiated. `.to_jax()` copies the `.nodes` to `.jaxnodes`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jaxnodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">value</span><span class="p">)[</span><span class="n">inds</span><span class="p">]</span>

    <span class="c1"># `jaxedges` contains only parameters (no indices).</span>
    <span class="c1"># `jaxedges` contains only non-Nan elements. This is unlike the channels where</span>
    <span class="c1"># we allow parameter sharing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s2">&quot;list&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">synapse</span><span class="o">.</span><span class="n">synapse_params</span><span class="p">:</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;type_ind&quot;</span><span class="p">])</span> <span class="o">==</span> <span class="n">i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">condition</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">synapse</span><span class="o">.</span><span class="n">synapse_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">jaxedges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])[</span><span class="n">condition</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.base.Module.vis" class="doc doc-heading">
            <code class=" language-python"><span class="n">vis</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="n">morph_plot_kwargs</span><span class="o">=</span><span class="p">{})</span></code>

<a href="#jaxley.modules.base.Module.vis" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Visualize the module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>ax</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="matplotlib.axes.Axes">Axes</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An axis into which to plot.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>col</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color for all branches.</p>
              </div>
            </td>
            <td>
                  <code>&#39;k&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>dims</code></td>
            <td>
                  <code><span title="typing.Tuple">Tuple</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of
two of them.</p>
              </div>
            </td>
            <td>
                  <code>(0, 1)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>morph_plot_kwargs</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword arguments passed to the plotting function.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/base.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">vis</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;line&quot;</span><span class="p">,</span>
    <span class="n">morph_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualize the module.</span>

<span class="sd">    Args:</span>
<span class="sd">        ax: An axis into which to plot.</span>
<span class="sd">        col: The color for all branches.</span>
<span class="sd">        dims: Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of</span>
<span class="sd">            two of them.</span>
<span class="sd">        morph_plot_kwargs: Keyword arguments passed to the plotting function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span><span class="p">(</span>
        <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
        <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
        <span class="n">view</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
        <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
        <span class="n">morph_plot_kwargs</span><span class="o">=</span><span class="n">morph_plot_kwargs</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="compartment">Compartment<a class="headerlink" href="#compartment" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.compartment.Compartment"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code></p>


        <p>Compartment class.</p>
<p>This class defines a single compartment that can be simulated by itself or
connected up into branches. It is the basic building block of a neuron model.</p>

              <details class="quote">
                <summary>Source code in <code>jaxley/modules/compartment.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Compartment</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compartment class.</span>

<span class="sd">    This class defines a single compartment that can be simulated by itself or</span>
<span class="sd">    connected up into branches. It is the basic building block of a neuron model.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">compartment_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;length&quot;</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span>  <span class="c1"># um</span>
        <span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># um</span>
        <span class="s2">&quot;axial_resistivity&quot;</span><span class="p">:</span> <span class="mf">5_000.0</span><span class="p">,</span>  <span class="c1"># ohm cm</span>
        <span class="s2">&quot;capacitance&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>  <span class="c1"># uF/cm^2</span>
    <span class="p">}</span>
    <span class="n">compartment_states</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;v&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mf">70.0</span><span class="p">}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Setting up the `nodes` for indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">comp_index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">branch_index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cell_index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compartment_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compartment_states</span><span class="p">)</span>

        <span class="c1"># Synapses.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">parent_branch_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">child_branch_index</span><span class="o">=</span><span class="p">[])</span>
        <span class="p">)</span>

        <span class="c1"># For morphology indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branchpoint_group_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children_in_level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents_in_level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Initialize the module.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_syns</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_conds</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Coordinates.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">init_conds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branch_uppers&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branch_lowers&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branch_diags&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mf">0.0</span><span class="p">]),</span>
        <span class="p">}</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div><h2 id="branch">Branch<a class="headerlink" href="#branch" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.branch.Branch"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code></p>


        <p>Branch class.</p>
<p>This class defines a single branch that can be simulated by itself or
connected to build a cell. A branch is linear segment of several compartments
and can be connected to no, one or more other branches at each end to build more
intricate cell morphologies.</p>

              <details class="quote">
                <summary>Source code in <code>jaxley/modules/branch.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Branch</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Branch class.</span>

<span class="sd">    This class defines a single branch that can be simulated by itself or</span>
<span class="sd">    connected to build a cell. A branch is linear segment of several compartments</span>
<span class="sd">    and can be connected to no, one or more other branches at each end to build more</span>
<span class="sd">    intricate cell morphologies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">branch_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">branch_states</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">compartments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Compartment</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Compartment</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">nseg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            compartments: A single compartment or a list of compartments that make up the</span>
<span class="sd">                branch.</span>
<span class="sd">            nseg: Number of segments to divide the branch into. If `compartments` is an</span>
<span class="sd">                a single compartment, than the compartment is repeated `nseg` times to</span>
<span class="sd">                create the branch.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="p">(</span><span class="n">Compartment</span><span class="p">,</span> <span class="n">List</span><span class="p">))</span> <span class="ow">or</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;Only Compartment or List[Compartment] is allowed.&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">nseg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;If `compartments` is not a list then you have to set `nseg`.&quot;</span>
        <span class="n">compartments</span> <span class="o">=</span> <span class="n">Compartment</span><span class="p">()</span> <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">compartments</span>
        <span class="n">nseg</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">nseg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nseg</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">):</span>
            <span class="n">compartment_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">compartments</span><span class="p">]</span> <span class="o">*</span> <span class="n">nseg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compartment_list</span> <span class="o">=</span> <span class="n">compartments</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compartment_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">compartment_list</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_states</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>

        <span class="c1"># Channels.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">compartment_list</span><span class="p">)</span>

        <span class="c1"># Synapse indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syn_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">global_pre_comp_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">global_post_comp_index</span><span class="o">=</span><span class="p">[],</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">parent_branch_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">child_branch_index</span><span class="o">=</span><span class="p">[])</span>
        <span class="p">)</span>

        <span class="c1"># For morphology indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branchpoint_group_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">children_in_level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents_in_level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_syns</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_conds</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Coordinates.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Ensure that hidden methods such as `__deepcopy__` still work.</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;comp&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">]:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span>
            <span class="n">compview</span> <span class="o">=</span> <span class="n">CompartmentView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">compview</span> <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;comp&quot;</span> <span class="k">else</span> <span class="n">compview</span><span class="o">.</span><span class="n">loc</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
            <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">GroupView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">CompartmentView</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;comp&quot;</span><span class="p">,</span> <span class="s2">&quot;loc&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not recognized.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_conds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="n">conds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_branch_conds</span><span class="p">(</span>
            <span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="p">)</span>
        <span class="n">cond_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
            <span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([]),</span>
        <span class="p">}</span>
        <span class="n">cond_params</span><span class="p">[</span><span class="s2">&quot;branch_lowers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cond_params</span><span class="p">[</span><span class="s2">&quot;branch_uppers&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cond_params</span><span class="p">[</span><span class="s2">&quot;branch_diags&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">cond_params</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">init_branch_conds</span><span class="p">(</span>
        <span class="n">axial_resistivity</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">radiuses</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lengths</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">nseg</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an axial resisitivity, set the coupling conductances.</span>

<span class="sd">        Args:</span>
<span class="sd">            axial_resistivity: Axial resistivity of each compartment.</span>
<span class="sd">            radiuses: Radius of each compartment.</span>
<span class="sd">            lengths: Length of each compartment.</span>
<span class="sd">            nseg: Number of compartments in the branch.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple of forward coupling conductances, backward coupling conductances, and summed coupling conductances.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute coupling conductance for segments within a branch.</span>
        <span class="c1"># `radius`: um</span>
        <span class="c1"># `r_a`: ohm cm</span>
        <span class="c1"># `length_single_compartment`: um</span>
        <span class="c1"># `coupling_conds`: S * um / cm / um^2 = S / cm / um</span>
        <span class="n">r1</span> <span class="o">=</span> <span class="n">radiuses</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">radiuses</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">r_a1</span> <span class="o">=</span> <span class="n">axial_resistivity</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">r_a2</span> <span class="o">=</span> <span class="n">axial_resistivity</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">l1</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">l2</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">coupling_conds_bwd</span> <span class="o">=</span> <span class="n">compute_coupling_cond</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r_a1</span><span class="p">,</span> <span class="n">r_a2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
        <span class="n">coupling_conds_fwd</span> <span class="o">=</span> <span class="n">compute_coupling_cond</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r_a2</span><span class="p">,</span> <span class="n">r_a1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">l1</span><span class="p">)</span>

        <span class="c1"># Compute the summed coupling conductances of each compartment.</span>
        <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nseg</span><span class="p">))</span>
        <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">summed_coupling_conds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coupling_conds_fwd</span><span class="p">)</span>
        <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">summed_coupling_conds</span><span class="o">.</span><span class="n">at</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coupling_conds_bwd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coupling_conds_fwd</span><span class="p">,</span> <span class="n">coupling_conds_bwd</span><span class="p">,</span> <span class="n">summed_coupling_conds</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.branch.Branch.__init__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">compartments</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nseg</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#jaxley.modules.branch.Branch.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>compartments</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.compartment.Compartment" href="#jaxley.modules.compartment.Compartment">Compartment</a>, <span title="typing.List">List</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.compartment.Compartment" href="#jaxley.modules.compartment.Compartment">Compartment</a>]]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A single compartment or a list of compartments that make up the
branch.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>nseg</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of segments to divide the branch into. If <code>compartments</code> is an
a single compartment, than the compartment is repeated <code>nseg</code> times to
create the branch.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/branch.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">compartments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Compartment</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Compartment</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nseg</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        compartments: A single compartment or a list of compartments that make up the</span>
<span class="sd">            branch.</span>
<span class="sd">        nseg: Number of segments to divide the branch into. If `compartments` is an</span>
<span class="sd">            a single compartment, than the compartment is repeated `nseg` times to</span>
<span class="sd">            create the branch.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="p">(</span><span class="n">Compartment</span><span class="p">,</span> <span class="n">List</span><span class="p">))</span> <span class="ow">or</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="p">),</span> <span class="s2">&quot;Only Compartment or List[Compartment] is allowed.&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">):</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">nseg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;If `compartments` is not a list then you have to set `nseg`.&quot;</span>
    <span class="n">compartments</span> <span class="o">=</span> <span class="n">Compartment</span><span class="p">()</span> <span class="k">if</span> <span class="n">compartments</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">compartments</span>
    <span class="n">nseg</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">nseg</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nseg</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compartments</span><span class="p">,</span> <span class="n">Compartment</span><span class="p">):</span>
        <span class="n">compartment_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">compartments</span><span class="p">]</span> <span class="o">*</span> <span class="n">nseg</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">compartment_list</span> <span class="o">=</span> <span class="n">compartments</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">compartment_list</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Indexing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">compartment_list</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">branch_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_states</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>

    <span class="c1"># Channels.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">compartment_list</span><span class="p">)</span>

    <span class="c1"># Synapse indexing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">syn_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">global_pre_comp_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">global_post_comp_index</span><span class="o">=</span><span class="p">[],</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">parent_branch_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">child_branch_index</span><span class="o">=</span><span class="p">[])</span>
    <span class="p">)</span>

    <span class="c1"># For morphology indexing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">branchpoint_group_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">children_in_level</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">parents_in_level</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_syns</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">initialized_conds</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Coordinates.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.branch.Branch.init_branch_conds" class="doc doc-heading">
            <code class=" language-python"><span class="n">init_branch_conds</span><span class="p">(</span><span class="n">axial_resistivity</span><span class="p">,</span> <span class="n">radiuses</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="n">nseg</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#jaxley.modules.branch.Branch.init_branch_conds" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Given an axial resisitivity, set the coupling conductances.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>axial_resistivity</code></td>
            <td>
                  <code><span title="jax.numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Axial resistivity of each compartment.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>radiuses</code></td>
            <td>
                  <code><span title="jax.numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Radius of each compartment.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>lengths</code></td>
            <td>
                  <code><span title="jax.numpy.ndarray">ndarray</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Length of each compartment.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>nseg</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of compartments in the branch.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="typing.Tuple">Tuple</span>[<span title="jax.numpy.ndarray">ndarray</span>, <span title="jax.numpy.ndarray">ndarray</span>, <span title="jax.numpy.ndarray">ndarray</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Tuple of forward coupling conductances, backward coupling conductances, and summed coupling conductances.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/branch.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">init_branch_conds</span><span class="p">(</span>
    <span class="n">axial_resistivity</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">radiuses</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">lengths</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">nseg</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given an axial resisitivity, set the coupling conductances.</span>

<span class="sd">    Args:</span>
<span class="sd">        axial_resistivity: Axial resistivity of each compartment.</span>
<span class="sd">        radiuses: Radius of each compartment.</span>
<span class="sd">        lengths: Length of each compartment.</span>
<span class="sd">        nseg: Number of compartments in the branch.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple of forward coupling conductances, backward coupling conductances, and summed coupling conductances.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Compute coupling conductance for segments within a branch.</span>
    <span class="c1"># `radius`: um</span>
    <span class="c1"># `r_a`: ohm cm</span>
    <span class="c1"># `length_single_compartment`: um</span>
    <span class="c1"># `coupling_conds`: S * um / cm / um^2 = S / cm / um</span>
    <span class="n">r1</span> <span class="o">=</span> <span class="n">radiuses</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r2</span> <span class="o">=</span> <span class="n">radiuses</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">r_a1</span> <span class="o">=</span> <span class="n">axial_resistivity</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r_a2</span> <span class="o">=</span> <span class="n">axial_resistivity</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">l1</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">l2</span> <span class="o">=</span> <span class="n">lengths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">coupling_conds_bwd</span> <span class="o">=</span> <span class="n">compute_coupling_cond</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r_a1</span><span class="p">,</span> <span class="n">r_a2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
    <span class="n">coupling_conds_fwd</span> <span class="o">=</span> <span class="n">compute_coupling_cond</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r_a2</span><span class="p">,</span> <span class="n">r_a1</span><span class="p">,</span> <span class="n">l2</span><span class="p">,</span> <span class="n">l1</span><span class="p">)</span>

    <span class="c1"># Compute the summed coupling conductances of each compartment.</span>
    <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nseg</span><span class="p">))</span>
    <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">summed_coupling_conds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coupling_conds_fwd</span><span class="p">)</span>
    <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">summed_coupling_conds</span><span class="o">.</span><span class="n">at</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">coupling_conds_bwd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coupling_conds_fwd</span><span class="p">,</span> <span class="n">coupling_conds_bwd</span><span class="p">,</span> <span class="n">summed_coupling_conds</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="cell">Cell<a class="headerlink" href="#cell" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.cell.Cell"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code></p>


        <p>Cell class.</p>
<p>This class defines a single cell that can be simulated by itself or
connected with synapses to build a network. A cell is made up of several branches
and supports intricate cell morphologies.</p>

              <details class="quote">
                <summary>Source code in <code>jaxley/modules/cell.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Cell</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cell class.</span>

<span class="sd">    This class defines a single cell that can be simulated by itself or</span>
<span class="sd">    connected with synapses to build a network. A cell is made up of several branches</span>
<span class="sd">    and supports intricate cell morphologies.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cell_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">cell_states</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">branches</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Branch</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Branch</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parents</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">xyzr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize a cell.</span>

<span class="sd">        Args:</span>
<span class="sd">            branches: A single branch or a list of branches that make up the cell.</span>
<span class="sd">                If a single branch is provided, then the branch is repeated `len(parents)`</span>
<span class="sd">                times to create the cell.</span>
<span class="sd">            parents: The parent branch index for each branch. The first branch has no</span>
<span class="sd">                parent and is therefore set to -1.</span>
<span class="sd">            xyzr: For every branch, the x, y, and z coordinates and the radius at the</span>
<span class="sd">                traced coordinates. Note that this is the full tracing (from SWC), not</span>
<span class="sd">                the stick representation coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="p">(</span><span class="n">Branch</span><span class="p">,</span> <span class="n">List</span><span class="p">))</span> <span class="ow">or</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;Only Branch or List[Branch] is allowed.&quot;</span>
        <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">parents</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;If `branches` is not a list then you have to set `parents`.&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">List</span><span class="p">):</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">branches</span>
            <span class="p">),</span> <span class="s2">&quot;Ensure equally many parents, i.e. len(branches) == len(parents).&quot;</span>

        <span class="n">branches</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">()</span> <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">branches</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">parents</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">parents</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">Branch</span><span class="p">):</span>
            <span class="n">branch_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">branches</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">branch_list</span> <span class="o">=</span> <span class="n">branches</span>

        <span class="k">if</span> <span class="n">xyzr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyzr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="n">xyzr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For every branch (`len(parents)`), we have a start and end point (`2`) and</span>
            <span class="c1"># a (x,y,z,r) coordinate for each of them (`4`).</span>
            <span class="c1"># Since `xyzr` is only inspected at `.vis()` and because it depends on the</span>
            <span class="c1"># (potentially learned) length of every compartment, we only populate</span>
            <span class="c1"># self.xyzr at `.vis()`.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">))]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="n">branch_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nseg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_children</span> <span class="o">=</span> <span class="n">compute_children_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)])</span>

        <span class="c1"># Indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_states</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span>

        <span class="c1"># Channels.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>

        <span class="c1"># Synapse indexing.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">syn_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span><span class="n">global_pre_comp_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">global_post_comp_index</span><span class="o">=</span><span class="p">[],</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">parent_branch_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="n">child_branch_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># For morphology indexing.</span>
        <span class="n">par_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">[</span><span class="s2">&quot;parent_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">[</span><span class="s2">&quot;child_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="n">remap_to_consecutive</span><span class="p">(</span><span class="n">par_inds</span><span class="p">)</span>

        <span class="c1"># TODO: does order have to be preserved?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">par_inds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">init_syns</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_conds</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Ensure that hidden methods such as `__deepcopy__` still work.</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;branch&quot;</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">BranchView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
            <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">GroupView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">BranchView</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;branch&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not recognized.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_morph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize morphology.&quot;&quot;&quot;</span>

        <span class="c1"># For Jaxley custom implementation.</span>
        <span class="n">children_and_parents</span> <span class="o">=</span> <span class="n">compute_morphology_indices_in_levels</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branchpoint_group_inds</span> <span class="o">=</span> <span class="n">build_branchpoint_group_inds</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>
        <span class="n">children_inds</span> <span class="o">=</span> <span class="n">children_and_parents</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span>
        <span class="n">parents_inds</span> <span class="o">=</span> <span class="n">children_and_parents</span><span class="p">[</span><span class="s2">&quot;parents&quot;</span><span class="p">]</span>

        <span class="n">levels</span> <span class="o">=</span> <span class="n">compute_levels</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children_in_level</span> <span class="o">=</span> <span class="n">compute_children_in_level</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">children_inds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents_in_level</span> <span class="o">=</span> <span class="n">compute_parents_in_level</span><span class="p">(</span>
            <span class="n">levels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="n">parents_inds</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">init_conds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an axial resisitivity, set the coupling conductances.&quot;&quot;&quot;</span>
        <span class="n">nbranches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span>
        <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>

        <span class="n">axial_resistivity</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
        <span class="n">radiuses</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>

        <span class="n">conds</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">Branch</span><span class="o">.</span><span class="n">init_branch_conds</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))(</span>
            <span class="n">axial_resistivity</span><span class="p">,</span> <span class="n">radiuses</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="p">)</span>
        <span class="n">coupling_conds_fwd</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coupling_conds_bwd</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># The conductance from the children to the branch point.</span>
        <span class="n">branchpoint_conds_children</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
            <span class="n">compute_coupling_cond_branchpoint</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)(</span>
            <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># The conductance from the parents to the branch point.</span>
        <span class="n">branchpoint_conds_parents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
            <span class="n">compute_coupling_cond_branchpoint</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)(</span>
            <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Weights with which the compartments influence their nearby node.</span>
        <span class="c1"># The impact of the children on the branch point.</span>
        <span class="n">branchpoint_weights_children</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">compute_impact_on_node</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span>
            <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># The impact of parents on the branch point.</span>
        <span class="n">branchpoint_weights_parents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">compute_impact_on_node</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span>
            <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_summed_coupling_conds</span><span class="p">(</span>
            <span class="n">summed_coupling_conds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
            <span class="n">branchpoint_conds_children</span><span class="p">,</span>
            <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">cond_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;branch_uppers&quot;</span><span class="p">:</span> <span class="n">coupling_conds_bwd</span><span class="p">,</span>
            <span class="s2">&quot;branch_lowers&quot;</span><span class="p">:</span> <span class="n">coupling_conds_fwd</span><span class="p">,</span>
            <span class="s2">&quot;branch_diags&quot;</span><span class="p">:</span> <span class="n">summed_coupling_conds</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">:</span> <span class="n">branchpoint_conds_children</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">:</span> <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">:</span> <span class="n">branchpoint_weights_children</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">:</span> <span class="n">branchpoint_weights_parents</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cond_params</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">update_summed_coupling_conds</span><span class="p">(</span>
        <span class="n">summed_conds</span><span class="p">,</span>
        <span class="n">child_inds</span><span class="p">,</span>
        <span class="n">par_inds</span><span class="p">,</span>
        <span class="n">branchpoint_conds_children</span><span class="p">,</span>
        <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform updates on the diagonal based on conductances of the branchpoints.</span>

<span class="sd">        Args:</span>
<span class="sd">            summed_conds: shape [num_branches, nseg]</span>
<span class="sd">            child_inds: shape [num_branches - 1]</span>
<span class="sd">            conds_fwd: shape [num_branches - 1]</span>
<span class="sd">            conds_bwd: shape [num_branches - 1]</span>
<span class="sd">            parents: shape [num_branches]</span>

<span class="sd">        Returns:</span>
<span class="sd">            Updated `summed_coupling_conds`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">summed_conds</span> <span class="o">=</span> <span class="n">summed_conds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">branchpoint_conds_children</span><span class="p">)</span>
        <span class="n">summed_conds</span> <span class="o">=</span> <span class="n">summed_conds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">branchpoint_conds_parents</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">summed_conds</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.cell.Cell.__init__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">branches</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xyzr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#jaxley.modules.cell.Cell.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize a cell.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>branches</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Union">Union</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.branch.Branch" href="#jaxley.modules.branch.Branch">Branch</a>, <span title="typing.List">List</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.branch.Branch" href="#jaxley.modules.branch.Branch">Branch</a>]]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A single branch or a list of branches that make up the cell.
If a single branch is provided, then the branch is repeated <code>len(parents)</code>
times to create the cell.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>parents</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The parent branch index for each branch. The first branch has no
parent and is therefore set to -1.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>xyzr</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="numpy.ndarray">ndarray</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>For every branch, the x, y, and z coordinates and the radius at the
traced coordinates. Note that this is the full tracing (from SWC), not
the stick representation coordinates.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/cell.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">branches</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Branch</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Branch</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">parents</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">xyzr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize a cell.</span>

<span class="sd">    Args:</span>
<span class="sd">        branches: A single branch or a list of branches that make up the cell.</span>
<span class="sd">            If a single branch is provided, then the branch is repeated `len(parents)`</span>
<span class="sd">            times to create the cell.</span>
<span class="sd">        parents: The parent branch index for each branch. The first branch has no</span>
<span class="sd">            parent and is therefore set to -1.</span>
<span class="sd">        xyzr: For every branch, the x, y, and z coordinates and the radius at the</span>
<span class="sd">            traced coordinates. Note that this is the full tracing (from SWC), not</span>
<span class="sd">            the stick representation coordinates.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="p">(</span><span class="n">Branch</span><span class="p">,</span> <span class="n">List</span><span class="p">))</span> <span class="ow">or</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="p">),</span> <span class="s2">&quot;Only Branch or List[Branch] is allowed.&quot;</span>
    <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">parents</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;If `branches` is not a list then you have to set `parents`.&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">List</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="n">branches</span>
        <span class="p">),</span> <span class="s2">&quot;Ensure equally many parents, i.e. len(branches) == len(parents).&quot;</span>

    <span class="n">branches</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">()</span> <span class="k">if</span> <span class="n">branches</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">branches</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">parents</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">parents</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">branches</span><span class="p">,</span> <span class="n">Branch</span><span class="p">):</span>
        <span class="n">branch_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">branches</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">branch_list</span> <span class="o">=</span> <span class="n">branches</span>

    <span class="k">if</span> <span class="n">xyzr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xyzr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="n">xyzr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># For every branch (`len(parents)`), we have a start and end point (`2`) and</span>
        <span class="c1"># a (x,y,z,r) coordinate for each of them (`4`).</span>
        <span class="c1"># Since `xyzr` is only inspected at `.vis()` and because it depends on the</span>
        <span class="c1"># (potentially learned) length of every compartment, we only populate</span>
        <span class="c1"># self.xyzr at `.vis()`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;NaN&quot;</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parents</span><span class="p">))]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="n">branch_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nseg</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">comb_children</span> <span class="o">=</span> <span class="n">compute_children_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)])</span>

    <span class="c1"># Indexing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">branch_list</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell_states</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
    <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span>

    <span class="c1"># Channels.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">branch_list</span><span class="p">)</span>

    <span class="c1"># Synapse indexing.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">syn_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">global_pre_comp_index</span><span class="o">=</span><span class="p">[],</span> <span class="n">global_post_comp_index</span><span class="o">=</span><span class="p">[],</span> <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="n">parent_branch_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="n">child_branch_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># For morphology indexing.</span>
    <span class="n">par_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">[</span><span class="s2">&quot;parent_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">[</span><span class="s2">&quot;child_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="n">remap_to_consecutive</span><span class="p">(</span><span class="n">par_inds</span><span class="p">)</span>

    <span class="c1"># TODO: does order have to be preserved?</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">par_inds</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">init_syns</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">initialized_conds</span> <span class="o">=</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.cell.Cell.init_conds" class="doc doc-heading">
            <code class=" language-python"><span class="n">init_conds</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></code>

<a href="#jaxley.modules.cell.Cell.init_conds" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Given an axial resisitivity, set the coupling conductances.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/cell.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">init_conds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given an axial resisitivity, set the coupling conductances.&quot;&quot;&quot;</span>
    <span class="n">nbranches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span>
    <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>

    <span class="n">axial_resistivity</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
    <span class="n">radiuses</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>

    <span class="n">conds</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">Branch</span><span class="o">.</span><span class="n">init_branch_conds</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))(</span>
        <span class="n">axial_resistivity</span><span class="p">,</span> <span class="n">radiuses</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
    <span class="p">)</span>
    <span class="n">coupling_conds_fwd</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coupling_conds_bwd</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># The conductance from the children to the branch point.</span>
    <span class="n">branchpoint_conds_children</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
        <span class="n">compute_coupling_cond_branchpoint</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)(</span>
        <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># The conductance from the parents to the branch point.</span>
    <span class="n">branchpoint_conds_parents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
        <span class="n">compute_coupling_cond_branchpoint</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)(</span>
        <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Weights with which the compartments influence their nearby node.</span>
    <span class="c1"># The impact of the children on the branch point.</span>
    <span class="n">branchpoint_weights_children</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">compute_impact_on_node</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span>
        <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># The impact of parents on the branch point.</span>
    <span class="n">branchpoint_weights_parents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">compute_impact_on_node</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span>
        <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_summed_coupling_conds</span><span class="p">(</span>
        <span class="n">summed_coupling_conds</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
        <span class="n">branchpoint_conds_children</span><span class="p">,</span>
        <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">cond_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;branch_uppers&quot;</span><span class="p">:</span> <span class="n">coupling_conds_bwd</span><span class="p">,</span>
        <span class="s2">&quot;branch_lowers&quot;</span><span class="p">:</span> <span class="n">coupling_conds_fwd</span><span class="p">,</span>
        <span class="s2">&quot;branch_diags&quot;</span><span class="p">:</span> <span class="n">summed_coupling_conds</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">:</span> <span class="n">branchpoint_conds_children</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">:</span> <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">:</span> <span class="n">branchpoint_weights_children</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">:</span> <span class="n">branchpoint_weights_parents</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">cond_params</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.cell.Cell.init_morph" class="doc doc-heading">
            <code class=" language-python"><span class="n">init_morph</span><span class="p">()</span></code>

<a href="#jaxley.modules.cell.Cell.init_morph" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize morphology.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/cell.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">init_morph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize morphology.&quot;&quot;&quot;</span>

    <span class="c1"># For Jaxley custom implementation.</span>
    <span class="n">children_and_parents</span> <span class="o">=</span> <span class="n">compute_morphology_indices_in_levels</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">),</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">branchpoint_group_inds</span> <span class="o">=</span> <span class="n">build_branchpoint_group_inds</span><span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">),</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>
    <span class="n">children_inds</span> <span class="o">=</span> <span class="n">children_and_parents</span><span class="p">[</span><span class="s2">&quot;children&quot;</span><span class="p">]</span>
    <span class="n">parents_inds</span> <span class="o">=</span> <span class="n">children_and_parents</span><span class="p">[</span><span class="s2">&quot;parents&quot;</span><span class="p">]</span>

    <span class="n">levels</span> <span class="o">=</span> <span class="n">compute_levels</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children_in_level</span> <span class="o">=</span> <span class="n">compute_children_in_level</span><span class="p">(</span><span class="n">levels</span><span class="p">,</span> <span class="n">children_inds</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">parents_in_level</span> <span class="o">=</span> <span class="n">compute_parents_in_level</span><span class="p">(</span>
        <span class="n">levels</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="n">parents_inds</span>
    <span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.cell.Cell.update_summed_coupling_conds" class="doc doc-heading">
            <code class=" language-python"><span class="n">update_summed_coupling_conds</span><span class="p">(</span><span class="n">summed_conds</span><span class="p">,</span> <span class="n">child_inds</span><span class="p">,</span> <span class="n">par_inds</span><span class="p">,</span> <span class="n">branchpoint_conds_children</span><span class="p">,</span> <span class="n">branchpoint_conds_parents</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#jaxley.modules.cell.Cell.update_summed_coupling_conds" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Perform updates on the diagonal based on conductances of the branchpoints.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>summed_conds</code></td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>shape [num_branches, nseg]</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>child_inds</code></td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>shape [num_branches - 1]</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>conds_fwd</code></td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>shape [num_branches - 1]</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>conds_bwd</code></td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>shape [num_branches - 1]</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>parents</code></td>
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>shape [num_branches]</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Updated <code>summed_coupling_conds</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/cell.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span> <span class="nf">update_summed_coupling_conds</span><span class="p">(</span>
    <span class="n">summed_conds</span><span class="p">,</span>
    <span class="n">child_inds</span><span class="p">,</span>
    <span class="n">par_inds</span><span class="p">,</span>
    <span class="n">branchpoint_conds_children</span><span class="p">,</span>
    <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform updates on the diagonal based on conductances of the branchpoints.</span>

<span class="sd">    Args:</span>
<span class="sd">        summed_conds: shape [num_branches, nseg]</span>
<span class="sd">        child_inds: shape [num_branches - 1]</span>
<span class="sd">        conds_fwd: shape [num_branches - 1]</span>
<span class="sd">        conds_bwd: shape [num_branches - 1]</span>
<span class="sd">        parents: shape [num_branches]</span>

<span class="sd">    Returns:</span>
<span class="sd">        Updated `summed_coupling_conds`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">summed_conds</span> <span class="o">=</span> <span class="n">summed_conds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">branchpoint_conds_children</span><span class="p">)</span>
    <span class="n">summed_conds</span> <span class="o">=</span> <span class="n">summed_conds</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">branchpoint_conds_parents</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">summed_conds</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="network">Network<a class="headerlink" href="#network" title="Permanent link">&para;</a></h2>


<div class="doc doc-object doc-class">



<a id="jaxley.modules.network.Network"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="jaxley.modules.base.Module" href="#jaxley.modules.base.Module">Module</a></code></p>


        <p>Network class.</p>
<p>This class defines a network of cells that can be connected with synapses.</p>

              <details class="quote">
                <summary>Source code in <code>jaxley/modules/network.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">Network</span><span class="p">(</span><span class="n">Module</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Network class.</span>

<span class="sd">    This class defines a network of cells that can be connected with synapses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">network_params</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">network_states</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Cell</span><span class="p">],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize network of cells and synapses.</span>

<span class="sd">        Args:</span>
<span class="sd">            cells: A list of cells that make up the network.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">+=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nseg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_states</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranchpoints_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranchpoints</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
            <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbranchpoints_per_cell</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">)]</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">comb_parents</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parents</span><span class="p">)]</span>
        <span class="p">)</span>

        <span class="c1"># Two columns: `parent_branch_index` and `child_branch_index`. One row per</span>
        <span class="c1"># branch, apart from those branches which do not have a parent (i.e.</span>
        <span class="c1"># -1 in parents). For every branch, tracks the global index of that branch</span>
        <span class="c1"># (`child_branch_index`) and the global index of its parent</span>
        <span class="c1"># (`parent_branch_index`).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="n">parent_branch_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">child_branch_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># For morphology indexing.</span>
        <span class="n">par_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">[</span><span class="s2">&quot;parent_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">[</span><span class="s2">&quot;child_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="n">remap_to_consecutive</span><span class="p">(</span><span class="n">par_inds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">par_inds</span><span class="p">)</span>  <span class="c1"># TODO: does order have to be preserved?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Channels.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_syns</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_conds</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Ensure that hidden methods such as `__deepcopy__` still work.</span>
        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;__&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;cell&quot;</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">CellView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span><span class="p">:</span>
            <span class="n">type_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">SynapseView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span><span class="p">[</span><span class="n">type_index</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">:</span>
            <span class="n">inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
            <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span>
            <span class="n">view</span><span class="p">[</span><span class="s2">&quot;global_cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">GroupView</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">CellView</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;cell&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Key </span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2"> not recognized.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">init_morph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">branchpoint_group_inds</span> <span class="o">=</span> <span class="n">build_branchpoint_group_inds</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children_in_level</span> <span class="o">=</span> <span class="n">merge_cells</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranchpoints</span><span class="p">,</span>
            <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">children_in_level</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">],</span>
            <span class="n">exclude_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parents_in_level</span> <span class="o">=</span> <span class="n">merge_cells</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranchpoints</span><span class="p">,</span>
            <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">parents_in_level</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">],</span>
            <span class="n">exclude_first</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_morph</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">init_conds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Given an axial resisitivity, set the coupling conductances.&quot;&quot;&quot;</span>
        <span class="n">nbranches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span>
        <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>

        <span class="n">axial_resistivity</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
        <span class="n">radiuses</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
        <span class="n">lengths</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>

        <span class="n">conds</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">Branch</span><span class="o">.</span><span class="n">init_branch_conds</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))(</span>
            <span class="n">axial_resistivity</span><span class="p">,</span> <span class="n">radiuses</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
        <span class="p">)</span>
        <span class="n">coupling_conds_fwd</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">coupling_conds_bwd</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># The conductance from the children to the branch point.</span>
        <span class="n">branchpoint_conds_children</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
            <span class="n">compute_coupling_cond_branchpoint</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)(</span>
            <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># The conductance from the parents to the branch point.</span>
        <span class="n">branchpoint_conds_parents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
            <span class="n">compute_coupling_cond_branchpoint</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)(</span>
            <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Weights with which the compartments influence their nearby node.</span>
        <span class="c1"># The impact of the children on the branch point.</span>
        <span class="n">branchpoint_weights_children</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">compute_impact_on_node</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span>
            <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="c1"># The impact of parents on the branch point.</span>
        <span class="n">branchpoint_weights_parents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">compute_impact_on_node</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span>
            <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">Cell</span><span class="o">.</span><span class="n">update_summed_coupling_conds</span><span class="p">(</span>
            <span class="n">summed_coupling_conds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
            <span class="n">branchpoint_conds_children</span><span class="p">,</span>
            <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">cond_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;branch_uppers&quot;</span><span class="p">:</span> <span class="n">coupling_conds_bwd</span><span class="p">,</span>
            <span class="s2">&quot;branch_lowers&quot;</span><span class="p">:</span> <span class="n">coupling_conds_fwd</span><span class="p">,</span>
            <span class="s2">&quot;branch_diags&quot;</span><span class="p">:</span> <span class="n">summed_coupling_conds</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">:</span> <span class="n">branchpoint_conds_children</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">:</span> <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">:</span> <span class="n">branchpoint_weights_children</span><span class="p">,</span>
            <span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">:</span> <span class="n">branchpoint_weights_parents</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">cond_params</span>

    <span class="k">def</span> <span class="nf">init_syns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize synapses.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># TODO(@michaeldeistler): should we also track this for channels?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">initialized_syns</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_step_synapse</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">syn_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform one step of the synapses and obtain their currents.&quot;&quot;&quot;</span>
        <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_synapse_state</span><span class="p">(</span><span class="n">states</span><span class="p">,</span> <span class="n">syn_channels</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">current_terms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_synapse_currents</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="n">syn_channels</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">delta_t</span><span class="p">,</span> <span class="n">edges</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="n">current_terms</span>

    <span class="k">def</span> <span class="nf">_step_synapse_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">syn_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

        <span class="n">grouped_syns</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">pre_syn_inds</span> <span class="o">=</span> <span class="n">grouped_syns</span><span class="p">[</span><span class="s2">&quot;global_pre_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">post_syn_inds</span> <span class="o">=</span> <span class="n">grouped_syns</span><span class="p">[</span><span class="s2">&quot;global_post_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">synapse_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grouped_syns</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">syn_channels</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">_name</span>
            <span class="p">),</span> <span class="s2">&quot;Mixup in the ordering of synapses. Please create an issue on Github.&quot;</span>
            <span class="n">synapse_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">synapse_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="n">synapse_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">synapse_param_names</span><span class="p">:</span>
                <span class="n">synapse_params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="n">synapse_states</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synapse_state_names</span><span class="p">:</span>
                <span class="n">synapse_states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="n">pre_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pre_syn_inds</span><span class="p">[</span><span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">post_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">post_syn_inds</span><span class="p">[</span><span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># State updates.</span>
            <span class="n">states_updated</span> <span class="o">=</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">update_states</span><span class="p">(</span>
                <span class="n">synapse_states</span><span class="p">,</span>
                <span class="n">delta_t</span><span class="p">,</span>
                <span class="n">voltages</span><span class="p">[</span><span class="n">pre_inds</span><span class="p">],</span>
                <span class="n">voltages</span><span class="p">[</span><span class="n">post_inds</span><span class="p">],</span>
                <span class="n">synapse_params</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># Rebuild state.</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">states_updated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">states</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="k">return</span> <span class="n">states</span>

    <span class="k">def</span> <span class="nf">_synapse_currents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">states</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">syn_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">,</span>
        <span class="n">delta_t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">edges</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="n">voltages</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="s2">&quot;v&quot;</span><span class="p">]</span>

        <span class="n">grouped_syns</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">group_keys</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">pre_syn_inds</span> <span class="o">=</span> <span class="n">grouped_syns</span><span class="p">[</span><span class="s2">&quot;global_pre_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">post_syn_inds</span> <span class="o">=</span> <span class="n">grouped_syns</span><span class="p">[</span><span class="s2">&quot;global_post_comp_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">synapse_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grouped_syns</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">syn_voltage_terms</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>
        <span class="n">syn_constant_terms</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voltages</span><span class="p">)</span>
        <span class="c1"># Run with two different voltages that are `diff` apart to infer the slope and</span>
        <span class="c1"># offset.</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">synapse_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">syn_channels</span><span class="p">):</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">synapse_type</span><span class="o">.</span><span class="n">_name</span>
            <span class="p">),</span> <span class="s2">&quot;Mixup in the ordering of synapses. Please create an issue on Github.&quot;</span>
            <span class="n">synapse_param_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_params</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">synapse_state_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">synapse_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="n">synapse_params</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">synapse_param_names</span><span class="p">:</span>
                <span class="n">synapse_params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
            <span class="n">synapse_states</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">synapse_state_names</span><span class="p">:</span>
                <span class="n">synapse_states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>

            <span class="c1"># Get pre and post indexes of the current synapse type.</span>
            <span class="n">pre_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">pre_syn_inds</span><span class="p">[</span><span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">post_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">post_syn_inds</span><span class="p">[</span><span class="n">synapse_names</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

            <span class="c1"># Compute slope and offset of the current through every synapse.</span>
            <span class="n">pre_v_and_perturbed</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">voltages</span><span class="p">[</span><span class="n">pre_inds</span><span class="p">],</span> <span class="n">voltages</span><span class="p">[</span><span class="n">pre_inds</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">post_v_and_perturbed</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">voltages</span><span class="p">[</span><span class="n">post_inds</span><span class="p">],</span> <span class="n">voltages</span><span class="p">[</span><span class="n">post_inds</span><span class="p">]</span> <span class="o">+</span> <span class="n">diff</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="n">synapse_currents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
                <span class="n">synapse_type</span><span class="o">.</span><span class="n">compute_current</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="p">)(</span>
                <span class="n">synapse_states</span><span class="p">,</span>
                <span class="n">pre_v_and_perturbed</span><span class="p">,</span>
                <span class="n">post_v_and_perturbed</span><span class="p">,</span>
                <span class="n">synapse_params</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">synapse_currents_dist</span> <span class="o">=</span> <span class="n">convert_point_process_to_distributed</span><span class="p">(</span>
                <span class="n">synapse_currents</span><span class="p">,</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">][</span><span class="n">post_inds</span><span class="p">],</span>
                <span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">][</span><span class="n">post_inds</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># Split into voltage and constant terms.</span>
            <span class="n">voltage_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">synapse_currents_dist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">synapse_currents_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">diff</span>
            <span class="n">constant_term</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">synapse_currents_dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">voltage_term</span> <span class="o">*</span> <span class="n">voltages</span><span class="p">[</span><span class="n">post_inds</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Gather slope and offset for every postsynaptic compartment.</span>
            <span class="n">gathered_syn_currents</span> <span class="o">=</span> <span class="n">gather_synapes</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">voltages</span><span class="p">),</span>
                <span class="n">post_inds</span><span class="p">,</span>
                <span class="n">voltage_term</span><span class="p">,</span>
                <span class="n">constant_term</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">syn_voltage_terms</span> <span class="o">+=</span> <span class="n">gathered_syn_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">syn_constant_terms</span> <span class="o">-=</span> <span class="n">gathered_syn_currents</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Add the synaptic currents through every compartment as state.</span>
            <span class="c1"># `post_syn_currents` is a `jnp.ndarray` of as many elements as there are</span>
            <span class="c1"># compartments in the network.</span>
            <span class="c1"># `[0]` because we only use the non-perturbed voltage.</span>
            <span class="n">states</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">synapse_type</span><span class="o">.</span><span class="n">_name</span><span class="si">}</span><span class="s2">_current&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">synapse_currents</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">states</span><span class="p">,</span> <span class="p">(</span><span class="n">syn_voltage_terms</span><span class="p">,</span> <span class="n">syn_constant_terms</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">vis</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">detail</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span>
        <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
        <span class="n">synapse_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span>
        <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
        <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;line&quot;</span><span class="p">,</span>
        <span class="n">layers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">morph_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">synapse_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">synapse_scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">networkx_options</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">layer_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Visualize the module.</span>

<span class="sd">        Args:</span>
<span class="sd">            detail: Either of [point, full]. `point` visualizes every neuron in the</span>
<span class="sd">                network as a dot (and it uses `networkx` to obtain cell positions).</span>
<span class="sd">                `full` plots the full morphology of every neuron. It requires that</span>
<span class="sd">                `compute_xyz()` has been run and allows for indivual neurons to be</span>
<span class="sd">                moved with `.move()`.</span>
<span class="sd">            col: The color in which cells are plotted. Only takes effect if</span>
<span class="sd">                `detail=&#39;full&#39;`.</span>
<span class="sd">            type: Either `line` or `scatter`. Only takes effect if `detail=&#39;full&#39;`.</span>
<span class="sd">            synapse_col: The color in which synapses are plotted. Only takes effect if</span>
<span class="sd">                `detail=&#39;full&#39;`.</span>
<span class="sd">            dims: Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of</span>
<span class="sd">                two of them.</span>
<span class="sd">            layers: Allows to plot the network in layers. Should provide the number of</span>
<span class="sd">                neurons in each layer, e.g., [5, 10, 1] would be a network with 5 input</span>
<span class="sd">                neurons, 10 hidden layer neurons, and 1 output neuron.</span>
<span class="sd">            morph_plot_kwargs: Keyword arguments passed to the plotting function for</span>
<span class="sd">                cell morphologies. Only takes effect for `detail=&#39;full&#39;`.</span>
<span class="sd">            synapse_plot_kwargs: Keyword arguments passed to the plotting function for</span>
<span class="sd">                syanpses. Only takes effect for `detail=&#39;full&#39;`.</span>
<span class="sd">            synapse_scatter_kwargs: Keyword arguments passed to the scatter function</span>
<span class="sd">                for the end point of synapses. Only takes effect for `detail=&#39;full&#39;`.</span>
<span class="sd">            networkx_options: Options passed to `networkx.draw()`. Only takes effect if</span>
<span class="sd">                `detail=&#39;point&#39;`.</span>
<span class="sd">            layer_kwargs: Only used if `layers` is specified and if `detail=&#39;full&#39;`.</span>
<span class="sd">                Can have the following entries: `within_layer_offset` (float),</span>
<span class="sd">                `between_layer_offset` (float), `vertical_layers` (bool).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;point&quot;</span><span class="p">:</span>
            <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_graph</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">layers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">multipartite_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">subset_key</span><span class="o">=</span><span class="s2">&quot;layer&quot;</span><span class="p">)</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">networkx_options</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">networkx_options</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">layers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Assemble cells in the network into layers.</span>
                <span class="n">global_counter</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">layers_config</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;within_layer_offset&quot;</span><span class="p">:</span> <span class="mf">500.0</span><span class="p">,</span>
                    <span class="s2">&quot;between_layer_offset&quot;</span><span class="p">:</span> <span class="mf">1500.0</span><span class="p">,</span>
                    <span class="s2">&quot;vertical_layers&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="n">layers_config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">layer_kwargs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">layer_ind</span><span class="p">,</span> <span class="n">num_in_layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ind_within_layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_in_layer</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">layers_config</span><span class="p">[</span><span class="s2">&quot;vertical_layers&quot;</span><span class="p">]:</span>
                            <span class="n">x_offset</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">ind_within_layer</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_in_layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                            <span class="p">)</span> <span class="o">*</span> <span class="n">layers_config</span><span class="p">[</span><span class="s2">&quot;within_layer_offset&quot;</span><span class="p">]</span>
                            <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">layer_ind</span><span class="p">)</span> <span class="o">*</span> <span class="n">layers_config</span><span class="p">[</span>
                                <span class="s2">&quot;between_layer_offset&quot;</span>
                            <span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">x_offset</span> <span class="o">=</span> <span class="n">layer_ind</span> <span class="o">*</span> <span class="n">layers_config</span><span class="p">[</span><span class="s2">&quot;between_layer_offset&quot;</span><span class="p">]</span>
                            <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">ind_within_layer</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_in_layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                            <span class="p">)</span> <span class="o">*</span> <span class="n">layers_config</span><span class="p">[</span><span class="s2">&quot;within_layer_offset&quot;</span><span class="p">]</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">global_counter</span><span class="p">)</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_offset</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_offset</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">global_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span><span class="p">(</span>
                <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
                <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
                <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
                <span class="n">view</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                <span class="n">morph_plot_kwargs</span><span class="o">=</span><span class="n">morph_plot_kwargs</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">pre_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;pre_locs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">post_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;post_locs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">pre_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;global_pre_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
            <span class="n">post_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;global_post_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

            <span class="n">dims_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">pre_loc</span><span class="p">,</span> <span class="n">post_loc</span><span class="p">,</span> <span class="n">pre_b</span><span class="p">,</span> <span class="n">post_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="n">pre_locs</span><span class="p">,</span> <span class="n">post_locs</span><span class="p">,</span> <span class="n">pre_branch</span><span class="p">,</span> <span class="n">post_branch</span>
            <span class="p">):</span>
                <span class="n">pre_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">pre_b</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># If only start and end point of a branch are traced, perform a</span>
                    <span class="c1"># linear interpolation to get the synpase location.</span>
                    <span class="n">pre_coord</span> <span class="o">=</span> <span class="n">pre_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pre_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pre_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">pre_loc</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If densely traced, use intermediate trace values for synapse loc.</span>
                    <span class="n">middle_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">pre_coord</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pre_loc</span><span class="p">)</span>
                    <span class="n">pre_coord</span> <span class="o">=</span> <span class="n">pre_coord</span><span class="p">[</span><span class="n">middle_ind</span><span class="p">]</span>

                <span class="n">post_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">post_b</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># If only start and end point of a branch are traced, perform a</span>
                    <span class="c1"># linear interpolation to get the synpase location.</span>
                    <span class="n">post_coord</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">post_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">post_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">post_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">post_loc</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># If densely traced, use intermediate trace values for synapse loc.</span>
                    <span class="n">middle_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">post_coord</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">post_loc</span><span class="p">)</span>
                    <span class="n">post_coord</span> <span class="o">=</span> <span class="n">post_coord</span><span class="p">[</span><span class="n">middle_ind</span><span class="p">]</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">pre_coord</span><span class="p">[</span><span class="n">dims_np</span><span class="p">],</span> <span class="n">post_coord</span><span class="p">[</span><span class="n">dims_np</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                    <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">synapse_col</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">synapse_plot_kwargs</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                    <span class="n">post_coord</span><span class="p">[</span><span class="n">dims_np</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">post_coord</span><span class="p">[</span><span class="n">dims_np</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="n">c</span><span class="o">=</span><span class="n">synapse_col</span><span class="p">,</span>
                    <span class="o">**</span><span class="n">synapse_scatter_kwargs</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;detail must be in {full, point}.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">_build_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">build_extents</span><span class="p">(</span><span class="o">*</span><span class="n">subset_sizes</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">pairwise</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">accumulate</span><span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="o">+</span> <span class="n">subset_sizes</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">layers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">extents</span> <span class="o">=</span> <span class="n">build_extents</span><span class="p">(</span><span class="o">*</span><span class="n">layers</span><span class="p">)</span>
            <span class="n">layers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span> <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">extents</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">)))</span>

        <span class="n">pre_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;pre_cell_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">post_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;post_cell_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">pre_cell</span><span class="p">,</span> <span class="n">post_cell</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">inds</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">graph</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.network.Network.__init__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span></code>

<a href="#jaxley.modules.network.Network.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize network of cells and synapses.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>cells</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<a class="autorefs autorefs-internal" title="jaxley.modules.cell.Cell" href="#jaxley.modules.cell.Cell">Cell</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of cells that make up the network.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/network.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cells</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Cell</span><span class="p">],</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize network of cells and synapses.</span>

<span class="sd">    Args:</span>
<span class="sd">        cells: A list of cells that make up the network.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span> <span class="o">+=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">xyzr</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">cells</span> <span class="o">=</span> <span class="n">cells</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nseg</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_append_params_and_states</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">network_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">network_states</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nbranchpoints_per_cell</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranchpoints</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
        <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbranchpoints_per_cell</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">nodes</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cells</span><span class="p">],</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;comp_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;branch_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
    <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;cell_index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="o">*</span><span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nseg</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranches_per_cell</span><span class="p">)]</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">parents</span> <span class="o">=</span> <span class="p">[</span><span class="n">cell</span><span class="o">.</span><span class="n">comb_parents</span> <span class="k">for</span> <span class="n">cell</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cells</span><span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parents</span><span class="p">)]</span>
    <span class="p">)</span>

    <span class="c1"># Two columns: `parent_branch_index` and `child_branch_index`. One row per</span>
    <span class="c1"># branch, apart from those branches which do not have a parent (i.e.</span>
    <span class="c1"># -1 in parents). For every branch, tracks the global index of that branch</span>
    <span class="c1"># (`child_branch_index`) and the global index of its parent</span>
    <span class="c1"># (`parent_branch_index`).</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="nb">dict</span><span class="p">(</span>
            <span class="n">parent_branch_index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">child_branch_index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># For morphology indexing.</span>
    <span class="n">par_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">[</span><span class="s2">&quot;parent_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">branch_edges</span><span class="p">[</span><span class="s2">&quot;child_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">child_belongs_to_branchpoint</span> <span class="o">=</span> <span class="n">remap_to_consecutive</span><span class="p">(</span><span class="n">par_inds</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">par_inds</span><span class="p">)</span>  <span class="c1"># TODO: does order have to be preserved?</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranchpoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">root_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cumsum_nbranches</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Channels.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_gather_channels_from_constituents</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">init_syns</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">initialized_conds</span> <span class="o">=</span> <span class="kc">False</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.network.Network.init_conds" class="doc doc-heading">
            <code class=" language-python"><span class="n">init_conds</span><span class="p">(</span><span class="n">params</span><span class="p">)</span></code>

<a href="#jaxley.modules.network.Network.init_conds" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Given an axial resisitivity, set the coupling conductances.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/network.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">init_conds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">Dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given an axial resisitivity, set the coupling conductances.&quot;&quot;&quot;</span>
    <span class="n">nbranches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_nbranches</span>
    <span class="n">nseg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comb_parents</span>

    <span class="n">axial_resistivity</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;axial_resistivity&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
    <span class="n">radiuses</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>
    <span class="n">lengths</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="s2">&quot;length&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">nbranches</span><span class="p">,</span> <span class="n">nseg</span><span class="p">))</span>

    <span class="n">conds</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">Branch</span><span class="o">.</span><span class="n">init_branch_conds</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))(</span>
        <span class="n">axial_resistivity</span><span class="p">,</span> <span class="n">radiuses</span><span class="p">,</span> <span class="n">lengths</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nseg</span>
    <span class="p">)</span>
    <span class="n">coupling_conds_fwd</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">coupling_conds_bwd</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">conds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># The conductance from the children to the branch point.</span>
    <span class="n">branchpoint_conds_children</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
        <span class="n">compute_coupling_cond_branchpoint</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)(</span>
        <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># The conductance from the parents to the branch point.</span>
    <span class="n">branchpoint_conds_parents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span>
        <span class="n">compute_coupling_cond_branchpoint</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)(</span>
        <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="c1"># Weights with which the compartments influence their nearby node.</span>
    <span class="c1"># The impact of the children on the branch point.</span>
    <span class="n">branchpoint_weights_children</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">compute_impact_on_node</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span>
        <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>
    <span class="c1"># The impact of parents on the branch point.</span>
    <span class="n">branchpoint_weights_parents</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">compute_impact_on_node</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))(</span>
        <span class="n">radiuses</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">axial_resistivity</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">lengths</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="n">summed_coupling_conds</span> <span class="o">=</span> <span class="n">Cell</span><span class="o">.</span><span class="n">update_summed_coupling_conds</span><span class="p">(</span>
        <span class="n">summed_coupling_conds</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">child_inds</span><span class="p">,</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">par_inds</span><span class="p">,</span>
        <span class="n">branchpoint_conds_children</span><span class="p">,</span>
        <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">cond_params</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;branch_uppers&quot;</span><span class="p">:</span> <span class="n">coupling_conds_bwd</span><span class="p">,</span>
        <span class="s2">&quot;branch_lowers&quot;</span><span class="p">:</span> <span class="n">coupling_conds_fwd</span><span class="p">,</span>
        <span class="s2">&quot;branch_diags&quot;</span><span class="p">:</span> <span class="n">summed_coupling_conds</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_conds_children&quot;</span><span class="p">:</span> <span class="n">branchpoint_conds_children</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_conds_parents&quot;</span><span class="p">:</span> <span class="n">branchpoint_conds_parents</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_weights_children&quot;</span><span class="p">:</span> <span class="n">branchpoint_weights_children</span><span class="p">,</span>
        <span class="s2">&quot;branchpoint_weights_parents&quot;</span><span class="p">:</span> <span class="n">branchpoint_weights_parents</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">cond_params</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.network.Network.init_syns" class="doc doc-heading">
            <code class=" language-python"><span class="n">init_syns</span><span class="p">()</span></code>

<a href="#jaxley.modules.network.Network.init_syns" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize synapses.</p>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/network.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">init_syns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize synapses.&quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">synapses</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># TODO(@michaeldeistler): should we also track this for channels?</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">synapse_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">synapse_param_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">synapse_state_names</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">initialized_syns</span> <span class="o">=</span> <span class="kc">True</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h3 id="jaxley.modules.network.Network.vis" class="doc doc-heading">
            <code class=" language-python"><span class="n">vis</span><span class="p">(</span><span class="n">detail</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">synapse_col</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="n">layers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">morph_plot_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">synapse_plot_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">synapse_scatter_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">networkx_options</span><span class="o">=</span><span class="p">{},</span> <span class="n">layer_kwargs</span><span class="o">=</span><span class="p">{})</span></code>

<a href="#jaxley.modules.network.Network.vis" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Visualize the module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>detail</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Either of [point, full]. <code>point</code> visualizes every neuron in the
network as a dot (and it uses <code>networkx</code> to obtain cell positions).
<code>full</code> plots the full morphology of every neuron. It requires that
<code>compute_xyz()</code> has been run and allows for indivual neurons to be
moved with <code>.move()</code>.</p>
              </div>
            </td>
            <td>
                  <code>&#39;full&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>col</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color in which cells are plotted. Only takes effect if
<code>detail='full'</code>.</p>
              </div>
            </td>
            <td>
                  <code>&#39;k&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>type</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Either <code>line</code> or <code>scatter</code>. Only takes effect if <code>detail='full'</code>.</p>
              </div>
            </td>
            <td>
                  <code>&#39;line&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>synapse_col</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The color in which synapses are plotted. Only takes effect if
<code>detail='full'</code>.</p>
              </div>
            </td>
            <td>
                  <code>&#39;b&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>dims</code></td>
            <td>
                  <code><span title="typing.Tuple">Tuple</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of
two of them.</p>
              </div>
            </td>
            <td>
                  <code>(0, 1)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>layers</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Allows to plot the network in layers. Should provide the number of
neurons in each layer, e.g., [5, 10, 1] would be a network with 5 input
neurons, 10 hidden layer neurons, and 1 output neuron.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>morph_plot_kwargs</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword arguments passed to the plotting function for
cell morphologies. Only takes effect for <code>detail='full'</code>.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>synapse_plot_kwargs</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword arguments passed to the plotting function for
syanpses. Only takes effect for <code>detail='full'</code>.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>synapse_scatter_kwargs</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword arguments passed to the scatter function
for the end point of synapses. Only takes effect for <code>detail='full'</code>.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>networkx_options</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Options passed to <code>networkx.draw()</code>. Only takes effect if
<code>detail='point'</code>.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>layer_kwargs</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Only used if <code>layers</code> is specified and if <code>detail='full'</code>.
Can have the following entries: <code>within_layer_offset</code> (float),
<code>between_layer_offset</code> (float), <code>vertical_layers</code> (bool).</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>jaxley/modules/network.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">vis</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">detail</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;full&quot;</span><span class="p">,</span>
    <span class="n">ax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Axes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span>
    <span class="n">synapse_col</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span>
    <span class="n">dims</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;line&quot;</span><span class="p">,</span>
    <span class="n">layers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">morph_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">synapse_plot_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">synapse_scatter_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">networkx_options</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
    <span class="n">layer_kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{},</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Axes</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visualize the module.</span>

<span class="sd">    Args:</span>
<span class="sd">        detail: Either of [point, full]. `point` visualizes every neuron in the</span>
<span class="sd">            network as a dot (and it uses `networkx` to obtain cell positions).</span>
<span class="sd">            `full` plots the full morphology of every neuron. It requires that</span>
<span class="sd">            `compute_xyz()` has been run and allows for indivual neurons to be</span>
<span class="sd">            moved with `.move()`.</span>
<span class="sd">        col: The color in which cells are plotted. Only takes effect if</span>
<span class="sd">            `detail=&#39;full&#39;`.</span>
<span class="sd">        type: Either `line` or `scatter`. Only takes effect if `detail=&#39;full&#39;`.</span>
<span class="sd">        synapse_col: The color in which synapses are plotted. Only takes effect if</span>
<span class="sd">            `detail=&#39;full&#39;`.</span>
<span class="sd">        dims: Which dimensions to plot. 1=x, 2=y, 3=z coordinate. Must be a tuple of</span>
<span class="sd">            two of them.</span>
<span class="sd">        layers: Allows to plot the network in layers. Should provide the number of</span>
<span class="sd">            neurons in each layer, e.g., [5, 10, 1] would be a network with 5 input</span>
<span class="sd">            neurons, 10 hidden layer neurons, and 1 output neuron.</span>
<span class="sd">        morph_plot_kwargs: Keyword arguments passed to the plotting function for</span>
<span class="sd">            cell morphologies. Only takes effect for `detail=&#39;full&#39;`.</span>
<span class="sd">        synapse_plot_kwargs: Keyword arguments passed to the plotting function for</span>
<span class="sd">            syanpses. Only takes effect for `detail=&#39;full&#39;`.</span>
<span class="sd">        synapse_scatter_kwargs: Keyword arguments passed to the scatter function</span>
<span class="sd">            for the end point of synapses. Only takes effect for `detail=&#39;full&#39;`.</span>
<span class="sd">        networkx_options: Options passed to `networkx.draw()`. Only takes effect if</span>
<span class="sd">            `detail=&#39;point&#39;`.</span>
<span class="sd">        layer_kwargs: Only used if `layers` is specified and if `detail=&#39;full&#39;`.</span>
<span class="sd">            Can have the following entries: `within_layer_offset` (float),</span>
<span class="sd">            `between_layer_offset` (float), `vertical_layers` (bool).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;point&quot;</span><span class="p">:</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_graph</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">layers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">multipartite_layout</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">subset_key</span><span class="o">=</span><span class="s2">&quot;layer&quot;</span><span class="p">)</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">networkx_options</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">networkx_options</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">detail</span> <span class="o">==</span> <span class="s2">&quot;full&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">layers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Assemble cells in the network into layers.</span>
            <span class="n">global_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">layers_config</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;within_layer_offset&quot;</span><span class="p">:</span> <span class="mf">500.0</span><span class="p">,</span>
                <span class="s2">&quot;between_layer_offset&quot;</span><span class="p">:</span> <span class="mf">1500.0</span><span class="p">,</span>
                <span class="s2">&quot;vertical_layers&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">layers_config</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">layer_kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">layer_ind</span><span class="p">,</span> <span class="n">num_in_layer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ind_within_layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_in_layer</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">layers_config</span><span class="p">[</span><span class="s2">&quot;vertical_layers&quot;</span><span class="p">]:</span>
                        <span class="n">x_offset</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">ind_within_layer</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_in_layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">layers_config</span><span class="p">[</span><span class="s2">&quot;within_layer_offset&quot;</span><span class="p">]</span>
                        <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">layer_ind</span><span class="p">)</span> <span class="o">*</span> <span class="n">layers_config</span><span class="p">[</span>
                            <span class="s2">&quot;between_layer_offset&quot;</span>
                        <span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x_offset</span> <span class="o">=</span> <span class="n">layer_ind</span> <span class="o">*</span> <span class="n">layers_config</span><span class="p">[</span><span class="s2">&quot;between_layer_offset&quot;</span><span class="p">]</span>
                        <span class="n">y_offset</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">ind_within_layer</span> <span class="o">-</span> <span class="p">(</span><span class="n">num_in_layer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                        <span class="p">)</span> <span class="o">*</span> <span class="n">layers_config</span><span class="p">[</span><span class="s2">&quot;within_layer_offset&quot;</span><span class="p">]</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">(</span><span class="n">global_counter</span><span class="p">)</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x_offset</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y_offset</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">global_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vis</span><span class="p">(</span>
            <span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span>
            <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
            <span class="n">view</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
            <span class="n">morph_plot_kwargs</span><span class="o">=</span><span class="n">morph_plot_kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">pre_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;pre_locs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">post_locs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;post_locs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">pre_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;global_pre_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">post_branch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s2">&quot;global_post_branch_index&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>

        <span class="n">dims_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pre_loc</span><span class="p">,</span> <span class="n">post_loc</span><span class="p">,</span> <span class="n">pre_b</span><span class="p">,</span> <span class="n">post_b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">pre_locs</span><span class="p">,</span> <span class="n">post_locs</span><span class="p">,</span> <span class="n">pre_branch</span><span class="p">,</span> <span class="n">post_branch</span>
        <span class="p">):</span>
            <span class="n">pre_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">pre_b</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pre_coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># If only start and end point of a branch are traced, perform a</span>
                <span class="c1"># linear interpolation to get the synpase location.</span>
                <span class="n">pre_coord</span> <span class="o">=</span> <span class="n">pre_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pre_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pre_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">pre_loc</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If densely traced, use intermediate trace values for synapse loc.</span>
                <span class="n">middle_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">pre_coord</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">pre_loc</span><span class="p">)</span>
                <span class="n">pre_coord</span> <span class="o">=</span> <span class="n">pre_coord</span><span class="p">[</span><span class="n">middle_ind</span><span class="p">]</span>

            <span class="n">post_coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyzr</span><span class="p">[</span><span class="n">post_b</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">post_coord</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># If only start and end point of a branch are traced, perform a</span>
                <span class="c1"># linear interpolation to get the synpase location.</span>
                <span class="n">post_coord</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">post_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">post_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">post_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">post_loc</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If densely traced, use intermediate trace values for synapse loc.</span>
                <span class="n">middle_ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">post_coord</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">post_loc</span><span class="p">)</span>
                <span class="n">post_coord</span> <span class="o">=</span> <span class="n">post_coord</span><span class="p">[</span><span class="n">middle_ind</span><span class="p">]</span>

            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">pre_coord</span><span class="p">[</span><span class="n">dims_np</span><span class="p">],</span> <span class="n">post_coord</span><span class="p">[</span><span class="n">dims_np</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">c</span><span class="o">=</span><span class="n">synapse_col</span><span class="p">,</span>
                <span class="o">**</span><span class="n">synapse_plot_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                <span class="n">post_coord</span><span class="p">[</span><span class="n">dims_np</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                <span class="n">post_coord</span><span class="p">[</span><span class="n">dims_np</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                <span class="n">c</span><span class="o">=</span><span class="n">synapse_col</span><span class="p">,</span>
                <span class="o">**</span><span class="n">synapse_scatter_kwargs</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;detail must be in {full, point}.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ax</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy"], "search": "../../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../../assets/javascripts/bundle.56dfad97.min.js"></script>
      
    
  </body>
</html>